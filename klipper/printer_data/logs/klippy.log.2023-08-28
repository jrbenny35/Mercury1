=============== Log rollover at Mon Aug 28 04:23:49 2023 ===============
Starting Klippy...
Args: ['/home/biqu/klipper/klippy/klippy.py', '/home/biqu/printer_data/config/printer.cfg', '-I', '/home/biqu/printer_data/comms/klippy.serial', '-l', '/home/biqu/printer_data/logs/klippy.log', '-a', '/home/biqu/printer_data/comms/klippy.sock']
Git version: 'v0.11.0-241-gffb5105b'
Branch: master
Remote: origin
Tracked URL: https://github.com/Klipper3d/klipper
CPU: 4 core ?
Python: '3.9.2 (default, Feb 28 2021, 17:03:44) \n[GCC 10.2.1 20210110]'
Start printer at Mon Aug 28 04:24:30 2023 (1693196670.1 61.0)
===== Config file =====
[virtual_sdcard]
path = ~/printer_data/gcodes
on_error_gcode = CANCEL_PRINT

[pause_resume]

[display_status]

[gcode_macro CANCEL_PRINT]
description = Cancels the current print.
	Usage: CANCEL_PRINT
rename_existing = _KM_CANCEL_PRINT_BASE
gcode = 
	_KM_CHECK_IS_PRINTING
	_KM_PRINT_STATUS ACTION=CHANGE STATUS=cancelling RESET_STACK=1
	SET_GCODE_VARIABLE MACRO=_print_end_inner VARIABLE=cancelled VALUE="{True}"
	PRINT_END
	_KM_CANCEL_PRINT_BASE
	{% if printer.pause_resume.is_paused %}
	RESTORE_GCODE_STATE NAME=_KM_PAUSE_OVERRIDE_STATE MOVE=0
	{% endif %}
	CLEAR_PAUSE
	_KM_APPLY_PRINT_OFFSET RESET=1
	{% if 'virtual_sdcard' in printer and not printer.virtual_sdcard.is_active %}
	SDCARD_RESET_FILE
	{% endif %}

[gcode_macro PAUSE]
description = Pause the actual running print
rename_existing = PAUSE_BASE
variable_restore_idle_timeout = 0
gcode = 
	
	{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}
	{% set idle_timeout = client.idle_timeout|default(0) %}
	
	SET_GCODE_VARIABLE MACRO=RESUME VARIABLE=last_extruder_temp VALUE={printer[printer.toolhead.extruder].target}
	
	{% if idle_timeout > 0 %}
	SET_GCODE_VARIABLE MACRO=PAUSE VARIABLE=restore_idle_timeout VALUE={printer.configfile.settings.idle_timeout.timeout}
	SET_IDLE_TIMEOUT TIMEOUT={idle_timeout}
	{% endif %}
	PAUSE_BASE
	_TOOLHEAD_PARK_PAUSE_CANCEL {rawparams}

[gcode_macro RESUME]
description = Resume the actual running print
rename_existing = RESUME_BASE
variable_last_extruder_temp = 0
gcode = 
	
	{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}
	{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}
	{% set sp_move = client.speed_move|default(velocity) %}
	
	
	{% if printer['gcode_macro PAUSE'].restore_idle_timeout > 0 %}
	SET_IDLE_TIMEOUT TIMEOUT={printer['gcode_macro PAUSE'].restore_idle_timeout}
	{% endif %}
	M109 S{last_extruder_temp}
	_CLIENT_EXTRUDE
	RESUME_BASE VELOCITY={params.VELOCITY|default(sp_move)}

[gcode_macro SET_PAUSE_NEXT_LAYER]
description = Enable a pause if the next layer is reached
gcode = 
	_KM_CHECK_IS_PRINTING
	{% set pause_next_layer =
	printer['gcode_macro SET_PRINT_STATS_INFO'].pause_next_layer %}
	{% set ENABLE = params.ENABLE | default(1) | int != 0 %}
	{% set MACRO = params.MACRO | default(pause_next_layer.call, True) %}
	SET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VALUE="{
	{ 'enable': False, 'call': MACRO }}" VARIABLE=pause_next_layer
	GCODE_AT_LAYER COMMAND="{MACRO|replace('\"','\\\"')
	}" CANCEL="{0 if ENABLE else 1}" LAYER="next"

[gcode_macro SET_PAUSE_AT_LAYER]
description = Enable/disable a pause if a given layer number is reached
gcode = 
	_KM_CHECK_IS_PRINTING
	{% set pause_at_layer =
	printer['gcode_macro SET_PRINT_STATS_INFO'].pause_at_layer %}
	
	{% set ENABLE = params.ENABLE | int != 0 if params.ENABLE is defined else
	params.LAYER is defined %}
	{% set LAYER = params.LAYER |
	default((pause_at_layer.layer|int,
	printer.print_stats.info.current_layer|int + 1)|max)%}
	{% set MACRO = params.MACRO | default(pause_at_layer.call, True) %}
	
	SET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{
	{ 'enable': False, 'layer': 0, 'call': MACRO }}"
	{% if ENABLE and pause_at_layer.enable %}
	
	GCODE_AT_LAYER COMMAND="{pause_at_layer.call|replace('\"','\\\"')
	}" CANCEL="{1}" LAYER="{pause_at_layer.layer}"
	{% endif %}
	
	GCODE_AT_LAYER COMMAND="{MACRO|replace('\"','\\\"')
	}" CANCEL="{0 if ENABLE else 1}" LAYER="{LAYER}"

[gcode_macro SET_PRINT_STATS_INFO]
rename_existing = _KM_SET_PRINT_STATS_INFO
description = Overwrite, to get pause_next_layer and pause_at_layer feature
variable_pause_next_layer = { 'enable': False, 'call': "PAUSE" }
variable_pause_at_layer = { 'enable': False, 'layer': 0, 'call': "PAUSE" }
gcode = 
	_KM_SET_PRINT_STATS_INFO {rawparams}

[gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL]
description = Helper: park toolhead used in PAUSE and CANCEL_PRINT
gcode = 
	
	{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}
	{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}
	{% set use_custom     = client.use_custom_pos|default(false)|lower == 'true' %}
	{% set custom_park_x  = client.custom_park_x|default(0.0) %}
	{% set custom_park_y  = client.custom_park_y|default(0.0) %}
	{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}
	{% set sp_hop         = client.speed_hop|default(15) * 60 %}
	{% set sp_move        = client.speed_move|default(velocity) * 60 %}
	
	{% set origin    = printer.gcode_move.homing_origin %}
	{% set act       = printer.gcode_move.gcode_position %}
	{% set max       = printer.toolhead.axis_maximum %}
	{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}
	{% set round_bed = True if printer.configfile.settings.printer.kinematics is in ['delta','polar','rotary_delta','winch']
	else False %}
	
	{% set z_min = params.Z_MIN|default(0)|float %}
	{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}
	{% set x_park = params.X       if params.X is defined
	else custom_park_x  if use_custom
	else 0.0            if round_bed
	else (max.x - 5.0) %}
	{% set y_park = params.Y       if params.Y is defined
	else custom_park_y  if use_custom
	else (max.y - 5.0)  if round_bed and z_park < cone
	else 0.0            if round_bed
	else (max.y - 5.0) %}
	
	_CLIENT_RETRACT
	{% if "xyz" in printer.toolhead.homed_axes %}
	G90
	G1 Z{z_park} F{sp_hop}
	G1 X{x_park} Y{y_park} F{sp_move}
	{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}
	{% else %}
	{action_respond_info("Printer not homed")}
	{% endif %}

[gcode_macro _CLIENT_EXTRUDE]
description = Extrudes, if the extruder is hot enough
gcode = 
	{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}
	{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}
	{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}
	{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}
	{% set absolute_extrude = printer.gcode_move.absolute_extrude %}
	
	{% if printer.extruder.can_extrude %}
	{% if use_fw_retract %}
	{% if length < 0 %}
	G10
	{% else %}
	G11
	{% endif %}
	{% else %}
	M83
	G1 E{length} F{(speed|float|abs) * 60}
	{% if absolute_extrude %}
	M82
	{% endif %}
	{% endif %}
	{% else %}
	{action_respond_info("Extruder not hot enough")}
	{% endif %}

[gcode_macro _CLIENT_RETRACT]
description = Retracts, if the extruder is hot enough
gcode = 
	{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}
	{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}
	{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}
	
	_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}

[gcode_macro _km_options]
variable_load_length = 90.0
variable_menu_temperature = [
	{'name' : 'PLA',  'extruder' : 200.0, 'bed' : 60.0},
	{'name' : 'PETG', 'extruder' : 230.0, 'bed' : 85.0},
	{'name' : 'ABS',  'extruder' : 245.0, 'bed' : 110.0, 'chamber' : 60}]
variable_start_purge_length = 50
variable_start_extruder_probing_temp = 150
variable_park_x = 200.0
variable_park_y = 200.0
gcode = 

[gcode_macro bed_mesh_calibrate_fast]
description = Wraps BED_MESH_CALIBRATE, scaling probe count to specified area.
	Usage: See Klipper documentation.
gcode = 
	
	BED_MESH_CHECK ABORT=1
	
	
	{% set calibrate_cmd =
	(printer["gcode_macro list_macros"].macros.bed_mesh_calibrate|
	default(["bed_mesh_calibrate"],True))[-1] %}
	
	{% set km = printer["gcode_macro _km_globals"] %}
	{% set probe_mesh_padding = km.probe_mesh_padding %}
	{% set probe_min_count = km.probe_min_count %}
	{% set probe_count_scale = km.probe_count_scale %}
	{% set bed_mesh = printer.configfile.settings.bed_mesh %}
	
	
	{%if "mesh_radius" not in bed_mesh and
	"MESH_RADIUS" not in params %}
	{% set safe_min_x = bed_mesh.mesh_min[0] %}
	{% set safe_min_y = bed_mesh.mesh_min[1] %}
	{% set safe_max_x = bed_mesh.mesh_max[0] %}
	{% set safe_max_y = bed_mesh.mesh_max[1] %}
	
	
	{% if "MESH_MIN" in params %}
	{% set mesh_min_x = (params.MESH_MIN.split(",")[0]|float -
	probe_mesh_padding, safe_min_x)|max %}
	{% set mesh_min_y = (params.MESH_MIN.split(",")[1]|float -
	probe_mesh_padding, safe_min_y)|max %}
	{% else %}
	{% set mesh_min_x = safe_min_x %}
	{% set mesh_min_y = safe_min_y %}
	{% endif %}
	{% if "MESH_MAX" in params %}
	{% set mesh_max_x = (params.MESH_MAX.split(",")[0]|float +
	probe_mesh_padding, safe_max_x)|min %}
	{% set mesh_max_y = (params.MESH_MAX.split(",")[1]|float +
	probe_mesh_padding, safe_max_y)|min %}
	{% else %}
	{% set mesh_max_x = safe_max_x %}
	{% set mesh_max_y = safe_max_y %}
	{% endif %}
	
	{% set probe_count = bed_mesh.probe_count if not params.PROBE_COUNT else
	params.PROBE_COUNT.split(",")|map('int')|list %}
	
	{% if "PROBE_COUNT" not in params %}
	{% set max_x_probes = probe_count[0] %}
	{% set max_y_probes = probe_count[-1] %}
	
	{% set x_probes = (max_x_probes * (mesh_max_x - mesh_min_x) /
	(safe_max_x - safe_min_x) * probe_count_scale)
	| round(0) | int %}
	{% set x_probes = ((x_probes, probe_min_count)|max, max_x_probes)|min %}
	
	{% set y_probes = (max_y_probes * (mesh_max_y - mesh_min_y ) /
	(safe_max_y - safe_min_y) * probe_count_scale )
	| round(0) | int %}
	{% set y_probes = ((y_probes, probe_min_count)|max, max_y_probes)|min %}
	
	{% if x_probes > 6 and y_probes < 4 %}
	{% set y_probes = 4 %}
	{% elif y_probes > 6 and x_probes < 4 %}
	{% set x_probes = 4 %}
	{% endif %}
	{% set probe_count = [x_probes,y_probes] %}
	{% elif probe_count|length == 1 %}
	{% set dummy = probe_count.append(probe_count[0]) %}
	{% endif %}
	
	
	
	
	
	
	
	{% if "relative_reference_index" in bed_mesh %}
	{% set row = (bed_mesh.relative_reference_index / bed_mesh.probe_count[0]
	)|int%}
	{% set rrf_x = (((safe_max_x - safe_min_x) /
	(bed_mesh.probe_count[0] - 1))|round(2, 'floor')) *
	(bed_mesh.relative_reference_index %
	bed_mesh.probe_count[-1]) %}
	{% if row % 2 %}
	{% set rrf_x = safe_max_x - rrf_x %}
	{% else %}
	{% set rrf_x = safe_min_x + rrf_x %}
	{% endif %}
	{% set rrf_y = (((safe_max_y - safe_min_y) /
	(bed_mesh.probe_count[-1] - 1))|round(2, 'floor')) *
	row + safe_min_x %}
	{% set x_dist = (mesh_max_x - mesh_min_x) / (probe_count[0] - 1) %}
	{% set y_dist = (mesh_max_y - mesh_min_y) / (probe_count[1] - 1) %}
	{% set rrf = {'x':0, 'y':0, 'dist':safe_max_x**2+safe_max_y**2,'pos':0} %}
	{% for row in range(probe_count[1])%}
	{% for col in range(probe_count[0])%}
	{% if row % 2 %}
	{% set x = mesh_max_x - col * x_dist %}
	{% else %}
	{% set x = mesh_min_x + col * x_dist %}
	{% endif %}
	{% set y = mesh_min_y + row * y_dist %}
	{% set dist = ((x - rrf_x)**2 + (y - rrf_y)**2)**0.5 %}
	{% if dist < rrf.dist %}
	{% set dummy = rrf.__setitem__("dist", dist) %}
	{% set dummy = rrf.__setitem__("x", x) %}
	{% set dummy = rrf.__setitem__("y", y) %}
	{% set dummy = rrf.__setitem__("pos", row * probe_count[1] + col) %}
	{% endif %}
	{% endfor %}
	{% endfor %}
	{% if rrf.x != rrf_x or rrf.y != rrf_y %}
	{action_respond_info("relative_reference_index remapped to"
	" %d (%.2f,%.2f) from %d (%.2f,%.2f)" %
	(rrf.pos, rrf.x, rrf.y,
	bed_mesh.relative_reference_index, rrf_x, rrf_y))}
	{% endif %}
	{% set dummy = params.__setitem__("RELATIVE_REFERENCE_INDEX", rrf.pos) %}
	{% endif %}
	
	{% set dummy = params.__setitem__("MESH_MIN", mesh_min_x~","~mesh_min_y) %}
	{% set dummy = params.__setitem__("MESH_MAX", mesh_max_x~","~mesh_max_y) %}
	{% set dummy = params.__setitem__("PROBE_COUNT", probe_count|join(',')) %}
	
	{% if probe_count[0] > 6 or probe_count[1]|default(0) > 6 %}
	{% set dummy = params.__setitem__("ALGORITHM", "bicubic") %}
	{% endif %}
	
	{% if "MESH_MIN" in params or "MESH_MAX" in params %}
	BED_MESH_CHECK {rawparams}
	{% endif %}
	{% else %}
	
	{% set dummy = params.__delitem__("MESH_MIN") %}
	{% set dummy = params.__delitem__("MESH_MAX") %}
	{% endif %}
	
	{% if "MESH_MIN" in params or "MESH_MAX" in params %}
	BED_MESH_CHECK ABORT=1{%for k in params%}{' '~k~'="'~params[k]~'"'}{%
	endfor%}
	{% endif %}
	_KM_PRINT_STATUS ACTION=PUSH_STATUS
	_KM_PRINT_STATUS ACTION=CHANGE STATUS=meshing
	{calibrate_cmd}{%for k in params%}{' '~k~'="'~params[k]~'"'}{%endfor%}
	_KM_PRINT_STATUS ACTION=CHANGE STATUS=pop_status

[gcode_macro bed_mesh_check]
description = Warns if bed_mesh config may generate an invalid mesh.
	Usage: BED_MESH_CHECK [MESH_MIN=<x,y>] [MESH_MAX=<x,y>] [ABORT=<0|1>]
gcode = 
	{% if printer.bed_mesh is defined %}
	{% set action = action_respond_info if params.ABORT|default(0)|int == 0 else
	action_raise_error %}
	{% set settings = printer.configfile.settings %}
	{% set x_min = settings.stepper_x.position_min %}
	{% set y_min = settings.stepper_y.position_min %}
	{% set x_max = settings.stepper_x.position_max %}
	{% set y_max = settings.stepper_y.position_max %}
	
	{% set label = "[bed_mesh] config" %}
	{% if "MESH_MIN" in params %}
	{% set label = "BED_MESH_CALIBRATE params" %}
	{% set mesh_min_x = params.MESH_MIN.split(",")[0]|float %}
	{% set mesh_min_y = params.MESH_MIN.split(",")[1]|float %}
	{% else %}
	{% set mesh_min_x = settings.bed_mesh.mesh_min[0] %}
	{% set mesh_min_y = settings.bed_mesh.mesh_min[1] %}
	{% endif %}
	{% if "MESH_MAX" in params %}
	{% set label = "BED_MESH_CALIBRATE params" %}
	{% set mesh_max_x = params.MESH_MAX.split(",")[0]|float %}
	{% set mesh_max_y = params.MESH_MAX.split(",")[1]|float %}
	{% else %}
	{% set mesh_max_x = settings.bed_mesh.mesh_max[0] %}
	{% set mesh_max_y = settings.bed_mesh.mesh_max[1] %}
	{% endif %}
	
	{% if "bltouch" in settings %}
	{% set x_offset = settings.bltouch.x_offset %}
	{% set y_offset = settings.bltouch.y_offset %}
	{% set probe = "bltouch" %}
	{% elif "probe" in settings %}
	{% set x_offset = settings.probe.x_offset %}
	{% set y_offset = settings.probe.y_offset %}
	{% set probe = "probe" %}
	{% else %}
	{% set x_offset = 0.0 %}
	{% set y_offset = 0.0 %}
	{% endif %}
	
	{% set output = [] %}
	{% set warn =
	"* mesh_%s (%f, %f) adjusted by " ~ probe ~
	".%s_offset (%f) can move out of range for "
	"stepper_%s.position_%s (%f)." %}
	{% if x_offset > 0 and (mesh_min_x - x_offset) < x_min %}
	{% set dummy = output.append(warn % ('min', mesh_min_x, mesh_min_y,
	'x', x_offset, 'x', 'min', x_min)) %}
	{% elif x_offset < 0 and (mesh_max_x - x_offset) > x_max %}
	{% set dummy = output.append(warn % ('max', mesh_max_x, mesh_max_y,
	'x', x_offset, 'x', 'max', x_max)) %}
	{% endif %}
	{% if y_offset > 0 and (mesh_min_y - y_offset) < y_min %}
	{% set dummy = output.append(warn % ('min', mesh_min_x, mesh_min_y,
	'y', y_offset, 'y', 'min', y_min)) %}
	{% elif y_offset < 0 and (mesh_max_y - y_offset) > y_max %}
	{% set dummy = output.append(warn % ('max', mesh_max_x, mesh_max_y,
	'y', y_offset, 'y', 'max', y_max)) %}
	{% endif %}
	
	{% if output %}
	{ action(
	"Warning: The following issue(s) were detected in your " ~ label ~
	":\n" ~ output|join("\n")) }
	{% endif %}
	{% endif %}

[gcode_macro _apply_bed_surface_offset]
gcode = 
	{% set surfaces = printer.save_variables.variables.bed_surfaces %}
	{% if surfaces.active %}
	SET_SURFACE_ACTIVE SURFACE={surfaces.active}
	{% endif %}

[gcode_macro _init_surfaces]
gcode = 
	{% set km = printer["gcode_macro _km_globals"] %}
	{% if "bed_surfaces" in printer.save_variables.variables %}
	{% set old_surfaces = printer.save_variables.variables.bed_surfaces %}
	{% else %}
	{% set old_surfaces = { 'active' : '', 'available' : {} } %}
	{% endif %}
	{% set settings = printer.configfile.settings %}
	{% set new_probe_z = (settings.probe | default(settings.bltouch) |
	default(settings.smart_effector) | default({})
	).z_offset|default(0.0)|float %}
	{% set new_endstop_z = (settings.stepper_z | default({})).position_endstop |
	default(0.0)|float %}
	{% if 'endstop_z' not in old_surfaces %}
	{% set dummy = old_surfaces.__setitem__('endstop_z', new_endstop_z) %}
	{% endif %}
	{% if 'probe_z' not in old_surfaces %}
	{% set dummy = old_surfaces.__setitem__('probe_z', new_probe_z) %}
	{% endif %}
	{% set surfaces = { 'active' : '', 'available' : {},
	'endstop_z' : old_surfaces.endstop_z,
	'probe_z' : old_surfaces.probe_z } %}
	{% for s in km.bed_surfaces %}
	{% set s = s.split()|join(' ')|lower %}
	{% if s|length > km.bed_surface_max_name_length or
	s|list|select("in", " \r\n\"\'")|list %}
	{action_raise_error('Invalid surface name "%s". Name must be %d or fewer '
	'characters and must not include space or quotation characters'
	| format(s, km.bed_surface_max_name_length))}
	{% endif %}
	{% if s in old_surfaces.available %}
	{% set dummy = surfaces.available.__setitem__(s,
	old_surfaces.available[s]) %}
	{% else %}
	{% set dummy = surfaces.available.__setitem__(s, {'offset' : 0.0}) %}
	{% endif %}
	{% endfor %}
	{% if old_surfaces.active in surfaces.available %}
	{% set dummy = surfaces.__setitem__('active', old_surfaces.active) %}
	{% elif km.bed_surfaces %}
	{% set dummy = surfaces.__setitem__('active', km.bed_surfaces[0]|lower) %}
	{% endif %}
	SAVE_VARIABLE VARIABLE=bed_surfaces VALUE="{surfaces}"
	_APPLY_BED_SURFACE_OFFSET
	{% if new_probe_z != surfaces.probe_z or
	new_endstop_z != surfaces.endstop_z %}
	{ action_respond_info(
	'Z probe offset or endstop position changed. Run ADJUST_SURFACE_OFFSETS '
	'to adjust the offset for all saved surfaces by the change differential, '
	'or run ADJUST_SURFACE_OFFSETS IGNORE=1 to hide this message without '
	'making changes.') }
	{% endif %}

[gcode_macro adjust_surface_offsets]
description = Adjusts surface offsets to account for changes in the Z endstop
	position or probe Z offset.
	Usage: ADJUST_SURFACE_OFFSETS [IGNORE]
gcode = 
	{% set surfaces = printer.save_variables.variables.bed_surfaces %}
	{% set settings = printer.configfile.settings %}
	{% set new_probe_z = (settings.probe | default(settings.bltouch) |
	default(settings.smart_effector) | default({})
	).z_offset|default(0.0)|float %}
	{% set new_endstop_z = (settings.stepper_z | default({})).position_endstop |
	default(0.0)|float %}
	{% set diff = (surfaces.probe_z - new_probe_z +
	surfaces.endstop_z - new_endstop_z)|round(6) %}
	{% if not params.IGNORE|default(0)|int %}
	{% for s in surfaces.available %}
	{% set offset = (surfaces.available[s].offset - diff)|round(6) %}
	{% set dummy = surfaces.available.__setitem__(s, {'offset' : offset}) %}
	{% endfor %}
	{ action_respond_info("All bed surfaces now adjusted by %1.4f"|
	format(diff))}
	{% elif diff != 0 %}
	{ action_respond_info("Status cleared without adjustment") }
	{% endif %}
	{% set dummy = surfaces.__setitem__('endstop_z', new_endstop_z| round(6)) %}
	{% set dummy = surfaces.__setitem__('probe_z', new_probe_z|round(6)) %}
	SAVE_VARIABLE VARIABLE=bed_surfaces VALUE="{surfaces}"

[gcode_macro set_surface_offset]
description = Sets the offset for a surface and moves the toolhead (if homed).
	Usage: SET_SURFACE_OFFSET [OFFSET=<offset>] [SURFACE=<surface>]
gcode = 
	{% set surfaces = printer.save_variables.variables.bed_surfaces %}
	{% set SURFACE = params.SURFACE|default(surfaces.active)|lower %}
	{% if SURFACE not in surfaces.available %}
	{ action_raise_error("Bed surface %s does not exist." | format(SURFACE)) }
	{% endif %}
	{% set active = surfaces.available[SURFACE] %}
	
	{% set OFFSET = params.OFFSET|default(active.offset)|float %}
	{% if OFFSET != active.offset %}
	{% set dummy = surfaces.available[SURFACE].__setitem__("offset", OFFSET) %}
	SAVE_VARIABLE VARIABLE=bed_surfaces VALUE="{surfaces}"
	{% if SURFACE == surfaces.active %}
	_km_set_gcode_offset_base Z="{OFFSET}" MOVE={
	1 if printer.toolhead.homed_axes == 'xyz' else 0}
	{% endif %}
	{% endif %}
	{ action_respond_info("Bed surface: %s Offset: %.3f"
	| format(SURFACE, OFFSET)) }
	
	{% set dummy = None if True else "
	{% set dummy = params.SURFACE|default(active surface) %}
	{% set dummy = params.OFFSET|default(none)|float %}
	" %}

[gcode_macro set_surface_active]
description = Sets the active bed surface and moves the toolhead (if homed). If
	no SURFACE argument is present the available surfaces are listed and the
	active one is preceded by a "*".
	Usage: SET_SURFACE_ACTIVE [SURFACE=<surface>]
gcode = 
	{% set surfaces = printer.save_variables.variables.bed_surfaces %}
	{% if "SURFACE" in params %}
	{% set SURFACE = params.SURFACE|lower %}
	{% if SURFACE not in surfaces.available %}
	{ action_raise_error("Bed surface %s does not exist." | format(SURFACE)) }
	{% endif %}
	{% if SURFACE != surfaces.active %}
	{% set dummy = surfaces.__setitem__("active", SURFACE) %}
	SAVE_VARIABLE VARIABLE=bed_surfaces VALUE="{surfaces}"
	{% endif %}
	{% if surfaces.available[SURFACE].offset !=
	printer.gcode_move.homing_origin.z %}
	_km_set_gcode_offset_base Z="{surfaces.available[SURFACE].offset
	}" MOVE={1 if printer.toolhead.homed_axes == 'xyz' else 0}
	{% endif %}
	{action_respond_info("Active bed surface: %s; offset: %.3f"
	| format(SURFACE, surfaces.available[SURFACE].offset))}
	{% else %}
	{% set output = [] %}
	{% for s in surfaces.available|list|sort %}
	{% set dummy = output.append("%s&nbsp;%s - offset: %.3f"
	| format("*" if s == surfaces.active else "&nbsp;",
	s, surfaces.available[s].offset)) %}
	{% endfor %}
	{action_respond_info(output|join('\n'))}
	{% endif %}
	
	{% set dummy = None if True else "
	{% set dummy = params.SURFACE|default(none) %}
	" %}

[gcode_macro set_gcode_offset]
description = Wraps SET_GCODE_OFFSET to update the current bed sheet offset.
	Usage: SET_GCODE_OFFSET [X=<pos>|X_ADJUST=<adjust>]
	[Y=<pos>|Y_ADJUST=<adjust>]
	[Z=<pos>|Z_ADJUST=<adjust>]
	[MOVE=1 [MOVE_SPEED=<speed>]]
rename_existing = _KM_SET_GCODE_OFFSET_BASE
gcode = 
	{% set surfaces = printer.save_variables.variables.bed_surfaces %}
	{% if surfaces.active and
	not printer["gcode_macro _km_save_state"].is_ephemeral %}
	{% set Z = params.Z|default(0.0)|float|round(6) %}
	{% set Z_ADJUST = params.Z_ADJUST|default(0.0)|float %}
	{% if 'Z' in params and
	Z != surfaces.available[surfaces.active].offset %}
	{% set dummy = surfaces.available[surfaces.active].__setitem__("offset",
	Z) %}
	SAVE_VARIABLE VARIABLE=bed_surfaces VALUE="{surfaces}"
	{% elif Z_ADJUST != 0.0 %}
	{% set dummy = surfaces.available[surfaces.active].__setitem__(
	"offset", (Z_ADJUST + printer.gcode_move.homing_origin.z)|round(6)) %}
	SAVE_VARIABLE VARIABLE=bed_surfaces VALUE="{surfaces}"
	{% endif %}
	{% endif %}
	_km_set_gcode_offset_base{% for k in params%}{' '~k~'="'~params[k]~'"'
	}{% endfor %}

[gcode_macro make_surface_mesh]
description = Generates and saves a mesh to automatically load in PRINT_START.
	Usage: MAKE_SURFACE_MESH [SURFACE=<surface>] [BED=<probing temperature>]
	[EXTRUDER=<probing temperature>]
	[MESH_MULTIPLIER=<integer multiple of mesh density>]
	[bed_mesh_calibrate parameters]
gcode = 
	{% set surfaces = printer.save_variables.variables.bed_surfaces %}
	{% set SURFACE = params.SURFACE|default(surfaces.active)|lower %}
	{% if SURFACE not in surfaces.available %}
	{ action_raise_error("Bed surface %s does not exist." | format(SURFACE)) }
	{% endif %}
	{% set dummy = params.__setitem__('PROFILE', SURFACE) %}
	{% set BED = params.BED|default(70) | int %}
	{% set km = printer["gcode_macro _km_globals"] %}
	{% set EXTRUDER = params.EXTRUDER|default(km.start_extruder_probing_temp) |
	int %}
	{% set MESH_MULTIPLIER = (params.MESH_MULTIPLIER|default(2)|int, 1)|max %}
	
	M104 S{EXTRUDER}
	M140 S{BED}
	G28
	
	
	{% if surfaces.available[SURFACE].offset !=
	printer.gcode_move.homing_origin.z %}
	_km_set_gcode_offset_base Z="{surfaces.available[SURFACE].offset
	}" MOVE=1
	{% endif %}
	
	
	{% if BED > 0 %}
	{action_respond_info("Stabilizing bed at %iC" | format(BED,))}
	_KM_PARK_IF_NEEDED HEATER=heater_bed RANGE=0.5
	{% if BED < (printer.heater_bed.temperature - 0.2) %}
	M190 R{BED}
	G4 P{((km.start_bed_heat_delay * 10, 30000)|min,
	km.start_bed_heat_delay)|max}
	{% else %}
	G4 P{km.start_bed_heat_delay}
	{% endif %}
	M190 R{BED}
	{% endif %}
	
	{% if EXTRUDER > 0 %}
	_KM_PARK_IF_NEEDED HEATER={printer.toolhead.extruder} RANGE=2
	M109 R{km.start_extruder_probing_temp}
	{% endif %}
	
	{% if km.start_home_z_at_temp and not bed_at_target %}
	G28 Z
	{% endif %}
	
	
	
	{% set probe_count = printer.configfile.settings.bed_mesh.probe_count
	if not params.PROBE_COUNT else
	params.PROBE_COUNT.split(",")|map('int')|list %}
	{% set dummy = params.__setitem__('PROBE_COUNT',(
	MESH_MULTIPLIER * (probe_count[0] - 1) + 1,
	MESH_MULTIPLIER * (probe_count[-1] - 1) + 1,)|join(',')) %}
	
	BED_MESH_CLEAR
	BED_MESH_CALIBRATE_FAST {%
	for k in params|reject('in',['BED','SURFACE'])|list %}{
	' ' ~ k ~ '=' ~ params[k] }{% endfor %}
	SAVE_CONFIG
	
	
	{% set dummy = None if True else "
	{% set dummy = params.MESH_MULTIPLIER|default(2) %}
	{% set dummy = params.SURFACE|default(active surface) %}
	" %}

[gcode_macro load_surface_mesh]
description = Attempts to load a mesh associated with the specified surface.
	Usage: LOAD_SURFACE_MESH [SURFACE=<surface>]
gcode = 
	{% set surfaces = printer.save_variables.variables.bed_surfaces %}
	{% set SURFACE = params.SURFACE|default(surfaces.active)|lower %}
	{% if SURFACE != surfaces.active %}
	SET_SURFACE_ACTIVE SURFACE={SURFACE}
	{% endif %}
	
	{% if SURFACE in printer.bed_mesh.profiles %}
	{% set mesh = printer.bed_mesh.profiles[SURFACE].mesh_params %}
	{% set default = printer.configfile.settings.bed_mesh %}
	
	{% if mesh.min_x <= (default.mesh_min[0] + 0.5) and
	mesh.min_y <= (default.mesh_min[1] + 0.5) and
	mesh.max_x >= (default.mesh_max[0] - 0.5) and
	mesh.max_y >= (default.mesh_max[1] - 0.5) and
	mesh.x_count >= default.probe_count[0] and
	mesh.y_count >= default.probe_count[-1] %}
	
	BED_MESH_PROFILE LOAD={SURFACE}
	{action_respond_info("Loaded mesh: %s" | format(SURFACE,))}
	{% endif %}
	{% endif %}

[gcode_macro m300]
description = Emits and audible beep.
	Usage: M300 [P<duration>] [S<frequency>]
gcode = 
	{% set settings = printer.configfile.settings %}
	{% if "output_pin beeper" in printer %}
	{% set P = (params.P|default(100)|int, 0)|max %}
	{% set S = (params.S|default(1000)|int, 1)|max %}
	SET_PIN PIN=beeper VALUE={% if settings["output_pin beeper"].pwm %}{
	settings["output_pin beeper"].scale|default(1.0) * 0.5
	} CYCLE_TIME={ 1.0 / S }{% else %}1{% endif %}
	G4 P{P}
	SET_PIN PIN=beeper VALUE=0
	{% else %}
	{action_respond_info(
	"M300 is disabled. To enable create an [output_pin beeper] config.")}
	{% endif %}

[gcode_macro set_draw_params]
description = Sets the default parameters used by DRAW_LINE_TO.
	Usage: SET_DRAW_PARAMS [HEIGHT=<mm>] [WIDTH=<mm>] [FEEDRATE=<mm/m>]
variable_height = 0.2
variable_width = 0.0
variable_feedrate = 1200
gcode = 
	{% set dparams = printer["gcode_macro set_draw_params"] %}
	{% for k in params %}
	{% set kl = k|lower %}
	{% if kl in dparams %}
	{% if dparams[kl] is float %}
	{% set v = params[k]|float %}
	{% elif dparams[kl] is integer %}
	{% set v = params[k]|int %}
	{% endif %}
	SET_GCODE_VARIABLE MACRO=set_draw_params VARIABLE={kl} VALUE="{v}"
	{% endif %}
	{% endfor %}

[gcode_macro draw_line_to]
description = Extrudes a line of filament at the specified height and width from
	the current coordinate to the supplied XY coordinate. (The height is used only
	to calculate the extrusion volume.)
	Usage: DRAW_LINE_TO [X=<pos>] [Y=<pos>] [HEIGHT=<mm>] [WIDTH=<mm>]
	[FEEDRATE=<mm/m>]
gcode = 
	{% set dparams = printer["gcode_macro set_draw_params"] %}
	{% set position = printer.gcode_move.gcode_position %}
	{% set X = params.X|default(position.x)|float %}
	{% set Y = params.Y|default(position.y)|float %}
	{% set HEIGHT = params.HEIGHT|default(dparams.height)|float %}
	{% set WIDTH = params.WIDTH|default(dparams.width)|float %}
	{% set FEEDRATE = params.FEEDRATE|default(dparams.feedrate)|int %}
	
	{% set distance = ((X - position.x) ** 2 + (Y - position.y) ** 2) ** 0.5 %}
	
	{% set filament_area = 3.14159 *
	(printer.configfile.settings[
	printer.toolhead.extruder].filament_diameter ** 2) / 4 %}
	{% set E = distance * ((WIDTH * HEIGHT) / filament_area) %}
	
	
	_KM_SAVE_GCODE_STATE NAME=_KM_PURGE
	G90
	G92 E0.0
	G1 X{"%.3f" % X} Y{"%.3f" % Y} E{"%.5f" % E} F{FEEDRATE}
	_KM_RESTORE_GCODE_STATE NAME=_KM_PURGE MOVE=0

[gcode_macro draw_purge_line]
description = Purges the specified length of filament as a line (or rows of
	lines) in front of the supplied print area. If no print area is specified the
	purge lines are drawn at the front edge of the maximum printable area. If no
	printable area is set it defaults to the XY axis limits.
	Usage: DRAW_PURGE_LINE [PRINT_MIN=<X,Y>] [PRINT_MAX=<X,Y>] [HEIGHT=<mm>]
	[WIDTH=<mm>] [LENGTH=<mm>]
gcode = 
	
	{% set km = printer["gcode_macro _km_globals"] %}
	{% set origin = printer.gcode_move.homing_origin %}
	{% set dummy = km.__setitem__('print_min', (km.print_min[0] - origin.x,
	km.print_min[1] - origin.y)) %}
	{% set dummy = km.__setitem__('print_max', (km.print_max[0] - origin.x,
	km.print_max[1] - origin.y)) %}
	
	{% if "PRINT_MIN" in params %}
	{% set PRINT_MIN = (
	(params.PRINT_MIN.split(",")[0]|float, km.print_min[0])|max,
	(params.PRINT_MIN.split(",")[1]|float, km.print_min[1])|max
	) %}
	{% else %}
	{% set PRINT_MIN = km.print_min %}
	{% endif %}
	{% if "PRINT_MAX" in params %}
	{% set PRINT_MAX = (
	(params.PRINT_MAX.split(",")[0]|float, km.print_max[0])|min,
	(params.PRINT_MAX.split(",")[1]|float, km.print_max[1])|min
	) %}
	{% else %}
	{% set PRINT_MAX = km.print_max %}
	{% endif %}
	{% set extruder = printer.toolhead.extruder|string %}
	{% set HEIGHT = params.HEIGHT|default(
	printer.configfile.settings[extruder].nozzle_diameter * 0.625)|float %}
	{% set WIDTH = params.WIDTH|default(
	printer.configfile.settings[extruder].nozzle_diameter * 1.25)|float %}
	{% set LENGTH = params.LENGTH|default(km.start_purge_length)|float %}
	
	{% set dparams = printer["gcode_macro set_draw_params"] %}
	{% set filament_area = 3.14159 *
	(printer.configfile.settings[extruder].filament_diameter ** 2) / 4 %}
	{% set purge_length = (LENGTH * filament_area) / (WIDTH * HEIGHT) %}
	{% set printable_length = PRINT_MAX[0] - PRINT_MIN[0] %}
	{% set purge_rows = (purge_length / printable_length)|round(0,'ceil')|int %}
	{% set printable_inset = (printable_length - purge_length / purge_rows) / 2 %}
	{% set PRINT_MIN = (PRINT_MIN[0] + printable_inset, PRINT_MIN[1]) %}
	{% set PRINT_MAX = (PRINT_MAX[0] - printable_inset, PRINT_MAX[1]) %}
	
	{% set y_start = (km.print_min[1], PRINT_MIN[1] - km.start_purge_clearance -
	(purge_rows + 0.5) * WIDTH )|max %}
	G90
	
	G1 X{"%.3f" % (PRINT_MIN[0] - 30, km.print_min[0])|max} Y{
	"%.3f" % (y_start - 10, km.print_min[1])|max} F{km.travel_speed_xy}
	
	G1 X{"%.3f" % (PRINT_MIN[0] - 2, km.print_min[0])|max} Y{"%.3f" % y_start} Z{
	"%.4f" % HEIGHT} F{km.travel_speed_xy}
	
	G92 E0.0
	G1 E{"%.3f" % km.start_purge_prime_length} F{km.load_priming_speed}
	G92 E0.0
	
	G1 X{"%.3f" % PRINT_MIN[0]} F{km.travel_speed_xy}
	{% for n in range(purge_rows - 1) %}
	{% set x_pos = PRINT_MIN[0] if n % 2 else PRINT_MAX[0] %}
	DRAW_LINE_TO HEIGHT="{HEIGHT}" WIDTH="{WIDTH}" X="{x_pos}" Y="{
	WIDTH * n + y_start}"
	DRAW_LINE_TO HEIGHT="{HEIGHT}" WIDTH="{WIDTH}" X="{x_pos}" Y="{
	WIDTH * (n + 1) + y_start}"
	{% endfor %}
	{% set x_pos = PRINT_MAX[0] if purge_rows % 2 else PRINT_MIN[0] %}
	DRAW_LINE_TO HEIGHT="{HEIGHT}" WIDTH="{WIDTH}" X="{x_pos}" Y="{
	WIDTH * (purge_rows - 1) + y_start}"
	G92 E0.0

[gcode_macro _check_fan_params]
gcode = 
	{% set MAXIMUM = params.MAXIMUM|default(
	printer["gcode_macro set_fan_scaling"].maximum)|int %}
	{% set MINIMUM = params.MINIMUM|default(
	printer["gcode_macro set_fan_scaling"].minimum)|int %}
	
	{% if params.SCALE and params.SCALE|float <= 0 %}
	{ action_raise_error("SCALE must be a positive value.") }
	{% elif MINIMUM < 0 or MINIMUM > 255 %}
	{ action_raise_error("MINIMUM must be between 0 and 255.") }
	{% elif MAXIMUM < 0 or MAXIMUM > 255 %}
	{ action_raise_error("MAXIMUM must be between 0 and 255.") }
	{% elif params.SPEED and (params.SPEED|int < 0 or params.SPEED|int > 255) %}
	{ action_raise_error("SPEED must be between 0 and 255.") }
	{% elif params.BOOST and (params.BOOST|int < 0 or params.BOOST|int > 255) %}
	{ action_raise_error("BOOST must be between 0 and 255.") }
	{% elif MINIMUM > MAXIMUM %}
	{ action_raise_error("MINIMUM must be less than or equal to MAXIMUM.") }
	{% endif %}

[gcode_macro set_fan_scaling]
description = Sets fan scaling factors applied to M106 command. If a speed is
	provided it will be adjusted according to the scaling parameters.
	Usage: SET_FAN_SCALING [SCALE=<scale>] [BOOST=<boost>] [MAXIMUM=<max>]
	[MINIMUM=<min>] [SPEED=<speed>]
variable_scale = 1.0
variable_boost = 0
variable_minimum = 0
variable_maximum = 255
variable_real_speed = 0
gcode = 
	_CHECK_FAN_PARAMS{% for k in params %}{' '~k~'='~params[k]}{% endfor %}
	{% set SCALE = params.SCALE|default(scale)|float %}
	{% set BOOST = params.BOOST|default(boost)|float %}
	{% set MAXIMUM = params.MAXIMUM|default(maximum)|int %}
	{% set MINIMUM = params.MINIMUM|default(minimum)|int %}
	{% set SPEED = params.SPEED|default(real_speed)|int %}
	
	{% if SCALE != 1.0 or BOOST != 0 or MAXIMUM != 255 or MINIMUM != 0 %}
	{action_respond_info("Fan: Scale: %.2f Minimum:%i Maximum: %i Speed: %i"|
	format(SCALE, MINIMUM, MAXIMUM, SPEED))}
	{% endif %}
	
	
	{% if params|length > 0 %}
	SET_GCODE_VARIABLE MACRO=set_fan_scaling VARIABLE=scale VALUE="{SCALE}"
	SET_GCODE_VARIABLE MACRO=set_fan_scaling VARIABLE=boost VALUE="{BOOST}"
	SET_GCODE_VARIABLE MACRO=set_fan_scaling VARIABLE=minimum VALUE="{MINIMUM}"
	SET_GCODE_VARIABLE MACRO=set_fan_scaling VARIABLE=maximum VALUE="{MAXIMUM}"
	
	M106 S{SPEED}
	{% endif %}
	
	{% set dummy = None if True else "
	{% set dummy = params.SCALE|default(1.0)|float %}
	{% set dummy = params.BUMP|default(0)|int %}
	{% set dummy = params.MAXIMUM|default(255)|int %}
	{% set dummy = params.MINIMUM|default(0)|int %}
	{% set dummy = params.SPEED|default(current speed)|int %}
	" %}

[gcode_macro reset_fan_scaling]
description = Clears all fan scaling factors.
	Usage: RESET_FAN_SCALING
gcode = 
	SET_FAN_SCALING SCALE=1.0 BOOST=0 MAXIMUM=255 MINIMUM=0

[gcode_macro m106]
description = Wraps M106 to implement scaling overrides.
rename_existing = M106.6245197
gcode = 
	{% set S = params.S|default(255)|int %}
	{% set scale = printer["gcode_macro set_fan_scaling"] %}
	SET_GCODE_VARIABLE MACRO=set_fan_scaling VARIABLE=real_speed VALUE="{S}"
	M106.6245197 S{((((S + scale.boost) * scale.scale) | round | int,
	scale.minimum) | max, scale.maximum) | min}

[gcode_macro _load_unload]
gcode = 
	{% set saved_extruder = printer.toolhead.extruder %}
	{% set EXTRUDER = params.EXTRUDER|default(saved_extruder)|lower %}
	{% set km = printer["gcode_macro _km_globals"] %}
	
	{% set BEEPS = params.BEEPS|default(8)|int if "output_pin beeper" in printer
	else 0 %}
	{% set default_minimum = km.load_min_temp if km.load_min_temp else
	(printer.configfile.settings[EXTRUDER].min_extrude_temp + 5) %}
	{% if 'MINIMUM' in params %}
	{% set MINIMUM = params.MINIMUM|int %}
	
	{% elif printer.pause_resume.is_paused and printer[EXTRUDER].target == 0 and
	printer["gcode_macro resume"].saved_extruder_temp %}
	{% set MINIMUM = printer["gcode_macro resume"].saved_extruder_temp %}
	
	{% elif printer[EXTRUDER].target > default_minimum %}
	{% set MINIMUM = printer[EXTRUDER].target %}
	{% else %}
	{% set MINIMUM = default_minimum %}
	{% endif %}
	{% if MINIMUM < printer.configfile.settings[EXTRUDER].min_extrude_temp %}
	{ action_raise_error("Extrude below minimum temp.") }
	{% elif printer.pause_resume.is_paused %}
	
	SET_GCODE_VARIABLE MACRO=resume VARIABLE=saved_e VALUE="{0.0}"
	{% endif %}
	{% set SPEED = params.SPEED|default(km.load_speed)|int %}
	{% set priming_length = km.load_priming_length %}
	{% set LENGTH = params.LENGTH|default(km.load_length)|float - priming_length%}
	{% if LENGTH < 0 %}
	{% set priming_length = (priming_length + LENGTH, 0)|max %}
	{% set LENGTH = 0 %}
	{% endif %}
	SAVE_GCODE_STATE NAME=_KM_LOAD_UNLOAD
	{% if EXTRUDER != saved_extruder%}
	ACTIVATE_EXTRUDER EXTRUDER={EXTRUDER}
	{% endif %}
	_KM_PRINT_STATUS ACTION=PUSH_STATUS
	{% if not printer.extruder.can_extrude or
	printer[EXTRUDER].target < default_minimum %}
	{action_respond_info("Preheating %s to %d" | format(EXTRUDER, MINIMUM))}
	M109 S{MINIMUM}
	{% endif %}
	_KM_PRINT_STATUS ACTION=CHANGE STATUS={"filament_load"
	if params.LOAD|int else "filament_unload"}
	M83
	{% set priming_speed = (km.load_priming_speed, SPEED)|min %}
	{% if params.LOAD|int %}
	G0 E{LENGTH} F{SPEED}
	G0 E{priming_length} F{priming_speed}
	G0 E{'%.4f' % -printer["gcode_macro resume"].saved_e} F{km.load_speed}
	{% else %}
	{% set pre_prime_distance = 5.0 %}
	{% set shaping_moves = 5 %}
	{% set shaping_distance = (shaping_moves * (1 + shaping_moves)/20) %}
	
	G0 E{pre_prime_distance} F{SPEED}
	G4 P500
	G0 E{'%.4f' % -(priming_length - shaping_distance)} F{SPEED}
	
	
	{% for i in range(1, shaping_moves + 1) %}
	G0 E2 F{priming_speed}
	G0 E-{2 + (0.1 * i)} F{priming_speed}
	{% endfor %}
	
	G0 E{'%.4f' % -(LENGTH + pre_prime_distance)} F{SPEED}
	{% endif %}
	RESTORE_GCODE_STATE NAME=_KM_LOAD_UNLOAD
	
	
	{% for i in range(BEEPS) %}
	M300 P100
	G4 P200
	{% endfor %}
	_KM_PRINT_STATUS ACTION=CHANGE STATUS=pop_status

[gcode_macro LOAD_FILAMENT]
description = Loads filament to the extruder.
	Usage: LOAD_FILAMENT [LENGTH=<distance>] [SPEED=<speed>]
	[EXTRUDER=<extruder>] [MINIMUM=<temperature>]
	[BEEPS=<beep count on completion>]
gcode = 
	_LOAD_UNLOAD LOAD=1{% for k in params
	%}{' '~k~'="'~params[k]~'"'}{% endfor %}
	
	
	{% set dummy = None if True else "
	M109
	{% set dummy = params.LENGTH|default(variable_load_length)|float %}
	{% set dummy = params.SPEED|default(variable_load_speed)|float %}
	{% set dummy = params.EXTRUDER|default(current extruder) %}
	{% set dummy = params.MINIMUM|default(min_extrude_temp)|int %}
	{% set dummy = params.BEEPS|default(10)|int %}
	" %}

[gcode_macro UNLOAD_FILAMENT]
description = Unloads filament from the extruder.
	Usage: UNLOAD_FILAMENT [LENGTH=<distance>] [SPEED=<speed>]
	[EXTRUDER=<extruder>] [MINIMUM=<temperature>]
	[BEEPS=<beep count on completion>]
gcode = 
	_LOAD_UNLOAD LOAD=0{% for k in params
	%}{' '~k~'="'~params[k]~'"'}{% endfor %}
	
	
	{% set dummy = None if True else "
	M109
	{% set dummy = params.LENGTH|default(variable_load_length)|float %}
	{% set dummy = params.SPEED|default(variable_load_speed)|float %}
	{% set dummy = params.EXTRUDER|default(default extruder) %}
	{% set dummy = params.MINIMUM|default(min_extrude_temp)|int %}
	{% set dummy = params.BEEPS|default(10)|int %}
	" %}

[gcode_macro _pause_inner_m700]
gcode = 
	{% set extruder = "extruder" ~ params.T|replace('0', '')
	if "T" in params else printer.toolhead.extruder %}
	{% if extruder != printer.toolhead.extruder%}
	ACTIVATE_EXTRUDER EXTRUDER={extruder}
	{% endif %}
	
	{% set z_param = (' Z="%f"' % params.Z) if 'Z' in params else "" %}
	
	{% if printer.idle_timeout.state|string == "Printing" %}
	PAUSE B="{0}" P=2{z_param}
	{% elif not printer.pause_resume.is_paused%}
	PARK B="{0}" P=2{z_param}
	{% endif %}

[gcode_macro m701]
description = Pauses/parks the toolhead then loads filament to the extruder.
	Usage: M701 [L<distance>] [Z<pos>] [T<extruder>]
gcode = 
	{% if 'U' in params %}
	{% if not 'L' in params %}
	RESPOND TYPE=error MSG="Argument \"U\" substituted for missing \"L\"."
	{% set dummy = params.__setitem__("L", params.U) %}
	{% else %}
	RESPOND TYPE=error MSG="Invalid argument \"U\" ignored."
	{% endif %}
	{% endif %}
	
	_PAUSE_INNER_M700 {% for k in params %}{' '~k~'="'~params[k]~'"'}{% endfor %}
	LOAD_FILAMENT BEEPS="{10}" LENGTH={
	params.L|default(printer["gcode_macro _km_globals"].load_length)|float}

[gcode_macro m702]
description = Pauses/parks the toolhead then unloads filament from the extruder.
	Usage: M702 [U<distance>] [Z<pos>] [T<extruder>]
gcode = 
	{% if 'L' in params %}
	{% if not 'U' in params %}
	RESPOND TYPE=error MSG="Argument \"L\" substituted for missing \"U\"."
	{% set dummy = params.__setitem__("U", params.L) %}
	{% else %}
	RESPOND TYPE=error MSG="Invalid argument \"L\" ignored."
	{% endif %}
	{% endif %}
	
	_PAUSE_INNER_M700 {% for k in params %}{' '~k~'="'~params[k]~'"'}{% endfor %}
	UNLOAD_FILAMENT BEEPS="{10}" LENGTH={
	params.U|default(printer["gcode_macro _km_globals"].load_length)|float}

[gcode_macro _km_globals]
variable_bed_surface_max_name_length = 10
variable_bed_surfaces = ['default']
variable_load_length = 90.0
variable_load_min_temp = 0
variable_load_priming_length = 20.0
variable_load_priming_speed = 200
variable_load_speed = 1200
variable_menu_show_octoprint = True
variable_menu_show_sdcard = True
variable_menu_temperature = [
	{'name' : 'PLA',  'extruder' : 200, 'bed' : 60},
	{'name' : 'PETG', 'extruder' : 230, 'bed' : 85},
	{'name' : 'ABS',  'extruder' : 245, 'bed' : 110}]
variable_park_x = 0.0
variable_park_y = 0.0
variable_park_z = 20.0
variable_print_min = ()
variable_print_max = ()
variable_pressure_advance_scale = -1.0
variable_probe_mesh_padding = 5.0
variable_probe_min_count = 3
variable_probe_count_scale = 1.0
variable_start_bed_heat_delay = 2000
variable_start_bed_heat_overshoot = 2.0
variable_start_clear_adjustments_at_end = True
variable_start_end_park_y = 0.0
variable_start_extruder_preheat_scale = 0.5
variable_start_extruder_probing_temp = 0
variable_start_home_z_at_temp = True
variable_start_level_bed_at_temp = True
variable_start_purge_clearance = 2.0
variable_start_purge_length = 0.0
variable_start_purge_prime_length = 12.0
variable_start_quad_gantry_level_at_temp = True
variable_start_random_placement_max = 0
variable_start_random_placement_padding = 10.0
variable_start_try_saved_surface_mesh = False
variable_start_z_tilt_adjust_at_temp = True
variable_travel_speed_xy = 3000
variable_travel_speed_z = 600
description = Initializes our globals, including any _km_options overrides.
gcode = 
	
	
	
	
	
	
	
	
	{% set required_sections = {"heater_bed" : None,
	"extruder" : None,
	"gcode_macro _km_options" : None,
	"idle_timeout" : ("gcode", "_KM_IDLE_TIMEOUT"),
	"pause_resume" : None,
	"respond" : None,
	"save_variables" : None,
	"virtual_sdcard" :
	("on_error_gcode", "CANCEL_PRINT")
	} %}
	{% set warn_removed = {
	"start_extruder_set_target_before_level" :
	"The start_extruder_set_target_before_level option has been removed. "
	"Use the start_extruder_probing_temp option instead to set a fixed "
	"probing temperature.",
	"start_gcode_before_print" :
	"The start_gcode_before_print option has been removed. The same effect "
	"can now be achieved by inserting custom gcode before the "
	"_PRINT_START_PHASE_PURGE line in your slicer's start gcode, or by "
	"wrapping the _PRINT_START_PHASE_PURGE macro. See the Slicer "
	"Configuration section in the readme for more information.",
	"velocity_decel_scale" :
	"The velocity_decel_scale option has been removed. Klipper's input "
	"shaping provides a superior mechanism for improving print quality "
	"at higher speeds.",
	} %}
	{% set output = [] %}
	{% for s in required_sections %}
	{% set f = required_sections[s][0] if required_sections[s] else None %}
	{% set v = required_sections[s][1] if required_sections[s] else None %}
	{% if s not in printer.configfile.config %}
	{% set dummy = output.append("Missing [%s] section.\n" | format(s)) %}
	{% elif f and
	(v not in printer.configfile.config[s][f]|default("")|upper) %}
	{% set dummy = output.append("Missing %s in %s for [%s] section.\n"
	| format(v, f, s)) %}
	{% endif %}
	{% endfor %}
	{% if output %}
	{ action_emergency_stop((
	"required printer.cfg section(s) missing:\n"
	~ output | join("\n")) ~
	"See readme: https://github.com/jschuh/klipper-macros\x23klipper-setup")
	}
	{% endif %}
	
	
	SET_GCODE_VARIABLE MACRO=_km_globals VARIABLE=start_level_bed_at_temp VALUE="{
	1 if printer.bed_mesh is defined else 0}"
	SET_GCODE_VARIABLE MACRO=_km_globals VARIABLE=start_quad_gantry_level_at_temp VALUE="{
	1 if printer.quad_gantry_level is defined else 0}"
	SET_GCODE_VARIABLE MACRO=_km_globals VARIABLE=start_z_tilt_adjust_at_temp VALUE="{
	1 if printer.z_tilt is defined else 0}"
	{% set toolhead = printer.toolhead %}
	SET_GCODE_VARIABLE MACRO=_km_globals VARIABLE=print_min VALUE="{
	(toolhead.axis_minimum.x, toolhead.axis_minimum.y)}"
	SET_GCODE_VARIABLE MACRO=_km_globals VARIABLE=print_max VALUE="{
	(toolhead.axis_maximum.x, toolhead.axis_maximum.y)}"
	SET_GCODE_VARIABLE MACRO=_km_globals VARIABLE=start_end_park_y VALUE="{
	toolhead.axis_maximum.y}"
	{% set settings = printer.configfile.settings %}
	SET_GCODE_VARIABLE MACRO=_km_globals VARIABLE=start_home_z_at_temp VALUE="{
	1 if ("stepper_z" in settings and
	settings.stepper_z.endstop_pin.split()|join("")|lower ==
	"probe:z_virtual_endstop") else 0}"
	
	{% set options = printer["gcode_macro _km_options"] %}
	{% set km = printer["gcode_macro _km_globals"] %}
	
	
	{% if options.park_x|default("")|string|lower == "min" %}
	{% set dummy = options.__setitem__("park_x",
	printer.configfile.settings.stepper_x.position_min) %}
	{% elif options.park_x|default("")|string|lower == "max" %}
	{% set dummy = options.__setitem__("park_x",
	printer.configfile.settings.stepper_x.position_max) %}
	{% endif %}
	{% if options.park_y|default("")|string|lower == "min" %}
	{% set dummy = options.__setitem__("park_y",
	printer.configfile.settings.stepper_y.position_min) %}
	{% elif options.park_y|default("")|string|lower == "max" %}
	{% set dummy = options.__setitem__("park_y",
	printer.configfile.settings.stepper_y.position_max) %}
	{% endif %}
	{% if options.start_end_park_y|default("")|string|lower == "min" %}
	{% set dummy = options.__setitem__("start_end_park_y",
	printer.configfile.settings.stepper_y.position_min) %}
	{% elif options.start_end_park_y|default("")|string|lower == "max" %}
	{% set dummy = options.__setitem__("start_end_park_y",
	printer.configfile.settings.stepper_y.position_max) %}
	{% endif %}
	{% if options.park_z|default("")|string|lower == "min" %}
	{% set dummy = options.__setitem__("park_z",
	printer.configfile.settings.stepper_z.position_min) %}
	{% elif options.park_z|default("")|string|lower == "max" %}
	{% set dummy = options.__setitem__("park_z",
	printer.configfile.settings.stepper_z.position_max) %}
	{% endif %}
	
	
	{% for k in options %}
	{% if k not in km %}
	{% if k in warn_removed %}
	{action_respond_info(warn_removed[k])}
	{% else %}
	{% set dummy = output.append("%s is not valid for _KM_OPTIONS." |
	format(k)) %}
	{% endif %}
	{% elif km[k] is string %}
	SET_GCODE_VARIABLE MACRO=_km_globals VARIABLE={k
	} VALUE="'{options[k]|replace('\\','\\\\')|replace('\'','\\\'')
	|replace('\"','\\\"')}'"
	{% elif km[k] is float %}
	SET_GCODE_VARIABLE MACRO=_km_globals VARIABLE={k
	} VALUE="{options[k]|float}"
	{% elif km[k] is integer or km[k] is boolean %}
	SET_GCODE_VARIABLE MACRO=_km_globals VARIABLE={k} VALUE="{options[k]|int}"
	{% elif km[k] is mapping %}
	{% if options[k] is not mapping %}
	{% set dummy = output.append("%s requires a mapping type." |
	format(k)) %}
	{% endif %}
	SET_GCODE_VARIABLE MACRO=_km_globals VARIABLE={k
	} VALUE="{options[k]|replace('\"','\\\"')}"
	{% elif km[k] is sequence %}
	{% if options[k] is not sequence %}
	{% set dummy = output.append("%s requires a sequence type." |
	format(k)) %}
	{% endif %}
	SET_GCODE_VARIABLE MACRO=_km_globals VARIABLE={k
	} VALUE="{options[k]|replace('\"','\\\"')}"
	{% else %}
	{% set dummy = output.append("%s is not a valid type for _KM_OPTIONS." |
	format(k)) %}
	{% endif %}
	{% endfor %}
	
	{% if "homing_override" in printer.configfile.config %}
	{% for l in printer.configfile.config.homing_override.gcode.split("\n") %}
	{% if " g28 " in (" " ~ l.split("\x23")[0].split(";")[0]|lower ~ " ") %}
	{% set dummy = output.append(
	"G28 in [homing_override] gcode. Replace with G28.6245197 to "
	"fix recursive macro call.\n"
	"See readme: https://github.com/jschuh/klipper-macros\x23g28") %}
	{% endif %}
	{% endfor %}
	{% endif %}
	SET_GCODE_VARIABLE MACRO=check_km_config VARIABLE=load_errors VALUE="{
	output|replace('\"','\\\"')}"
	M400

[delayed_gcode INIT_GLOBALS]
initial_duration = 1
gcode = 
	LIST_MACROS SILENT=1
	_KM_GLOBALS
	
	CHECK_KM_CONFIG
	_INIT_SURFACES
	BED_MESH_CHECK
	
	SET_DRAW_PARAMS WIDTH="{printer.configfile.settings.extruder.nozzle_diameter}"
	
	_KM_OPTIONS
	_KM_PRINT_STATUS ACTION=CHANGE STATUS=ready

[gcode_macro check_km_config]
variable_load_errors = []
description = Checks global variables and throws an error on any invalid values.
	Does nothing if the config has no errors.
gcode = 
	{% set km = printer["gcode_macro _km_globals"] %}
	{% set toolhead = printer.toolhead %}
	{% set output = load_errors %}
	{% if km.park_x > toolhead.axis_maximum.x or
	km.park_x < toolhead.axis_minimum.x %}
	{% set dummy = output.append("park_x is invalid.") %}
	{% endif %}
	{% if km.park_y > toolhead.axis_maximum.y or
	km.park_y < toolhead.axis_minimum.y %}
	{% set dummy = output.append("park_y is invalid.") %}
	{% endif %}
	{% if km.park_z > toolhead.axis_maximum.z or
	km.park_z < toolhead.axis_minimum.z %}
	{% set dummy = output.append("park_z is invalid.") %}
	{% endif %}
	{% if km.print_max[0] > toolhead.axis_maximum.x or
	km.print_max[1] > toolhead.axis_maximum.y %}
	{% set dummy = output.append("print_max is invalid.") %}
	{% endif %}
	{% if km.print_min[0] < toolhead.axis_minimum.x or
	km.print_min[1] < toolhead.axis_minimum.y %}
	{% set dummy = output.append("print_min is invalid.") %}
	{% endif %}
	{% if km.start_extruder_preheat_scale > 1.0 or
	km.start_extruder_preheat_scale < 0.0 %}
	{% set dummy = output.append("extruder_preheat_scale is invalid.") %}
	{% endif %}
	{% if km.load_length >
	printer.configfile.settings["extruder"].max_extrude_only_distance %}
	{% set dummy = output.append(
	"load_length exceeds max_extrude_only_distance.") %}
	{% endif %}
	{% if km.load_length < km.load_priming_length %}
	{% set dummy = output.append(
	"load_length is shorter than load_priming_length.") %}
	{% endif %}
	{% if km.load_length < 0.0 %}
	{% set dummy = output.append("load_length is negative.") %}
	{% endif %}
	{% if km.load_priming_length < 0.0 %}
	{% set dummy = output.append("load_priming_length is negative.") %}
	{% endif %}
	
	
	{% if output %}
	{ action_raise_error(output|sort|join('\nError: ')) }
	{% endif %}
	M400

[gcode_macro kmvars]
description = Lists global variables used by klipper-macros.
	Usage: KMVARS [SEARCH=<search_string>]
gcode = 
	{% set SEARCH = params.SEARCH|default(params.S|default(""))|lower %}
	{% set km = printer["gcode_macro _km_globals"] %}
	{% set output = [] %}
	{% for k in km %}
	{% if SEARCH in k %}
	{% set dummy = output.append(k ~ ": " ~ km[k]) %}
	{% endif %}
	{% endfor %}
	{ action_respond_info(output|sort|join('\n')) }

[gcode_macro check_macro_docs]
description = Lists macros lacking proper documentation.
	Usage: CHECK_MACRO_DOCS [USAGE=<0|1>] [HIDDEN=<1|0>] [RENAMED=<1|0>]
gcode = 
	{% set USAGE = params.USAGE|default(0)|int %}
	{% set HIDDEN = params.HIDDEN|default(0)|int %}
	{% set RENAMED = params.RENAMED|default(0)|int %}
	{% set output = [] %}
	{%set config = printer.configfile.config %}
	{% for k in config|sort %}
	{% if k.startswith("gcode_macro") %}
	{% set name = k.split()[1] %}
	{% set desc = config[k].description|default("") %}
	{% set is_renamed = config[k].rename_existing|default("") %}
	{% if (not desc or (USAGE and not "Usage: "~name.upper() in desc)) and
	(HIDDEN or not name.startswith('_')) and (RENAMED or is_renamed) %}
	{% set dummy = output.append("%s&nbsp;%s: missing %s."
	| format("*" if is_renamed else "&nbsp;", name,
	"description" if not desc else "usage")) %}
	{% endif %}
	{% endif %}
	{% endfor %}
	{action_respond_info(output|join("\n"))}

[gcode_macro listvars]
description = Lists per-macro variables with a name containing SEARCH. This is
	useful for debugging macros by allowing you to probe printer state. Be very
	careful, however, as an overly broad SEARCH parameter can take a long time
	to process and potentially hang or crash klipper.
	Usage: LISTVARS SEARCH=<search_string>
gcode = 
	
	{% if 'SEARCH' not in params and 'S' not in params %}
	{ action_raise_error("Must provide a SEARCH parameter.") }
	{% endif %}
	{% set SEARCH = params.SEARCH|default(params.S)|lower %}
	{% set ns = namespace() %}
	{% set output = [] %}
	{% for item in printer %}
	{% if item is not string %}
	{% set ns.path = ['printer', "[%s]" % (item|string), ''] %}
	{% elif ' ' in item %}
	{% set ns.path = ['printer', "['%s']" % (item), ''] %}
	{% else %}
	{% set ns.path = ['printer.', item, ''] %}
	{% endif %}
	
	{% if SEARCH in ns.path|lower %}
	{% set dummy = output.append(ns.path|join) %}
	{% endif %}
	
	{% if printer[item].items() %}
	{% for childkey, child in printer[item].items() recursive %}
	{% set ns.path = ns.path[:loop.depth|int + 1] %}
	{% if childkey is not string %}
	{% set null = ns.path.append("[%s]" % (childkey|string)) %}
	{% elif ' ' in childkey %}
	{% set null = ns.path.append("['%s']" % (childkey)) %}
	{% else %}
	{% set null = ns.path.append(".%s" % (childkey)) %}
	{% endif %}
	
	{% if child is mapping  %}
	{loop(child.items())}
	{% else %}
	{% if SEARCH in ns.path|lower %}
	{% set dummy = output.append("%s : %s" % (ns.path|join, child)) %}
	{% endif %}
	{% endif %}
	{% endfor %}
	{% endif %}
	{% endfor %}
	{ action_respond_info(output|join("\n")) }

[gcode_macro list_macros]
description = Lists registered macros (and optionally show variable state).
	Usage: LISTVARS SEARCH=<search_string> VARS=<0|1> SILENT=<0|1>
variable_macros = {}
gcode = 
	
	{% if not macros %}
	{% set renames = {} %}
	{% for k in printer.configfile.config %}
	{% if k.lower().startswith("gcode_macro") and
	printer.configfile.config[k].rename_existing %}
	{% set name = k.split(None, 1)[1] | lower %}
	{% set dummy = renames.__setitem__(name,
	[printer.configfile.config[k].rename_existing|lower] +
	renames[name]|default([])) %}
	{% endif %}
	{% endfor %}
	{% for k in printer %}
	{% if k.lower().startswith("gcode_macro") %}
	{% set name = k.split(None, 1)[1] | lower %}
	{% set dummy = macros.__setitem__(name, renames[name]|default([])) %}
	{% endif %}
	{% endfor %}
	{% endif %}
	
	{% if params.SILENT|default(0)|int == 0 %}
	_LIST_MACROS_DISPLAY {rawparams}
	{% endif %}

[gcode_macro _list_macros_display]
gcode = 
	{% set SEARCH = params.SEARCH | default(params.S) | default("") | lower %}
	{% set VARS = params.VARS | default(params.V) | default(0) | int != 0 %}
	
	{% set macros = printer["gcode_macro list_macros"].macros %}
	{% set output = [] %}
	{% for k in macros %}
	{% if SEARCH in k | lower %}
	{% set line = k ~ ((" (renames: %s)" % (macros[k]|join(","))) if macros[k]
	else "") %}
	{% set outvars = [] %}
	{% if VARS %}
	{% for v in printer["gcode_macro " ~ k] | sort %}
	{% set dummy = outvars.append("\n* %s: %s" %
	(v, printer["gcode_macro " ~ k][v]|string)) %}
	{% endfor %}
	{% endif %}
	{% set dummy = output.append(line + outvars | join("")) %}
	{% endif %}
	{% endfor %}
	{ action_respond_info(output | sort | join("\n")) }

[gcode_macro set_heater_temperature_scaled]
gcode = 
	{% set HEATER = params.HEATER.lower() %}
	{% set TARGET = params.TARGET|default(0.0)|float %}
	{% set scaled_heaters =
	printer["gcode_macro set_heater_scaling"].scaled_heaters %}
	{% if HEATER in scaled_heaters %}
	{% set scales = scaled_heaters[HEATER] %}
	{% set dummy = scales.__setitem__("real_target", TARGET) %}
	{%if TARGET > 0.0 %}
	{% set TARGET = (((TARGET + scales.bump) * scales.scale, scales.minimum)
	| max, scales.maximum)|min %}
	{% endif %}
	{% endif %}
	SET_HEATER_TEMPERATURE HEATER="{HEATER}" TARGET={TARGET}

[gcode_macro temperature_wait_scaled]
gcode = 
	{% set SENSOR = params.SENSOR.lower() %}
	{% set heater = SENSOR if not SENSOR.startswith("heater_generic") else
	SENSOR.split()[1] %}
	{% set scaled_heaters =
	printer["gcode_macro set_heater_scaling"].scaled_heaters %}
	{% if heater in scaled_heaters %}
	{% set scales = scaled_heaters[heater] %}
	{% if "MINIMUM" in params and MINIMUM > 0.0 %}
	{% set MINIMUM = (((MINIMUM + scales.bump) * scales.scale, scales.minimum)
	| max, scales.maximum)|min %}
	{% endif %}
	{% if "MAXIMUM" in params and MAXIMUM > 0.0 %}
	{% set MAXIMUM = (((MAXIMUM + scales.bump) * scales.scale, scales.minimum)
	| max, scales.maximum)|min %}
	{% endif %}
	{% else %}
	{% set settings = printer.configfile.settings[SENSOR] %}
	{% set MINIMUM = params.MINIMUM|default(settings.min_temp) %}
	{% set MAXIMUM = params.MAXIMUM|default(settings.max_temp) %}
	{% endif %}
	{% if printer[sensor].temperature < MINIMUM or
	printer[sensor].temperature > MAXIMUM %}
	TEMPERATURE_WAIT SENSOR="{SENSOR}" MINIMUM={MINIMUM} MAXIMUM={MAXIMUM}
	{% endif %}

[gcode_macro _gcode_wait_wrapper_inner]
gcode = 
	
	
	{% set sensor = params.HEATER if params.HEATER in
	printer.heaters.available_heaters
	else ("heater_generic " ~ params.HEATER) %}
	{% set target = printer[sensor].target %}
	{% if 'R' in params and target > 0.0 %}
	{% set T = params.T|default("") %}
	M{params.M}.6245197 S{target} { (" T"~T) if T else "" }
	{% elif printer[sensor].temperature < target %}
	TEMPERATURE_WAIT SENSOR="{sensor}" MINIMUM={target}
	{% endif %}

[gcode_macro _gcode_wait_wrapper]
gcode = 
	{% set target = params.S | default(params.R | default(0))| float %}
	SET_HEATER_TEMPERATURE_SCALED HEATER="{params.HEATER}" TARGET={target}
	_GCODE_WAIT_WRAPPER_INNER{%
	for k in params %}{' '~k~'="'~params[k]~'"'}{% endfor %}

[gcode_macro m109]
rename_existing = M109.6245197
gcode = 
	{% set extruder = "extruder" ~ params.T|replace('0', '')
	if "T" in params else printer.toolhead.extruder %}
	_KM_PRINT_STATUS ACTION=PUSH_STATUS
	_KM_PRINT_STATUS ACTION=CHANGE STATUS=extruder_heating
	_GCODE_WAIT_WRAPPER HEATER={extruder}{%
	for k in params %}{' '~k~'="'~params[k]~'"'}{% endfor %}
	_KM_PRINT_STATUS ACTION=CHANGE STATUS=pop_status

[gcode_macro m190]
rename_existing = M190.6245197
gcode = 
	_KM_PRINT_STATUS ACTION=PUSH_STATUS
	_KM_PRINT_STATUS ACTION=CHANGE STATUS=bed_heating
	_GCODE_WAIT_WRAPPER HEATER=heater_bed {%
	for k in params %}{' '~k~'="'~params[k]~'"'}{% endfor %}
	_KM_PRINT_STATUS ACTION=CHANGE STATUS=pop_status

[gcode_macro m191]
description = Sets chamber temperature (with wait for heating).
	Usage: M191 [S<temp>]
gcode = 
	
	{% if "R" in params %}
	{% set dummy = params.__setitem__("S", params.R) %}
	{% endif %}
	_KM_PRINT_STATUS ACTION=PUSH_STATUS
	_KM_PRINT_STATUS ACTION=CHANGE STATUS=chamber_heating
	_GCODE_WAIT_WRAPPER HEATER=chamber {%
	for k in params %}{' '~k~'="'~params[k]~'"'}{% endfor %}
	_KM_PRINT_STATUS ACTION=CHANGE STATUS=pop_status

[gcode_macro m104]
rename_existing = M104.6245197
gcode = 
	{% set extruder = "extruder" ~ params.T|replace('0', '')
	if "T" in params else printer.toolhead.extruder %}
	SET_HEATER_TEMPERATURE_SCALED HEATER={extruder} TARGET={params.S|default(0)}

[gcode_macro m140]
rename_existing = M140.6245197
gcode = 
	SET_HEATER_TEMPERATURE_SCALED HEATER=heater_bed TARGET={params.S|default(0)}

[gcode_macro m141]
description = Sets chamber temperature.
	Usage: M141 [S<temp>]
gcode = 
	SET_HEATER_TEMPERATURE_SCALED HEATER=chamber TARGET={params.S|default(0)}

[gcode_macro _check_heater_params]
gcode = 
	{% set HEATER = params.HEATER|lower %}
	{% set sensor = params.HEATER %}
	{% if HEATER not in printer.heaters.available_heaters %}
	{% set sensor = "heater_generic " ~ HEATER %}
	{% if sensor not in printer.heaters.available_heaters %}
	{ action_raise_error("The value '%s' is not valid for HEATER"
	| format(HEATER)) }
	{% endif %}
	{% endif %}
	{% set settings = printer.configfile.settings[sensor] %}
	{% set scaled_heaters =
	printer["gcode_macro set_heater_scaling"].scaled_heaters %}
	{% if HEATER is in scaled_heaters %}
	{% set scales = scaled_heaters[HEATER] %}
	{% else %}
	{% set scales = { "scale": 1.0, "bump": 0.0, "minimum": settings.min_temp,
	"maximum": settings.max_temp,
	"real_target": printer[sensor].target} %}
	{% endif %}
	{% set SCALE = params.SCALE|default(scales.scale)|float %}
	{% set BUMP = params.BUMP|default(scales.bump)|float %}
	{% set MINIMUM = params.MINIMUM|default(scales.minimum)|float %}
	{% set MAXIMUM = params.MAXIMUM|default(scales.maximum)|float %}
	
	{% if SCALE <= 0 %}
	{ action_raise_error("SCALE must be a positive value.") }
	{% elif MINIMUM < settings.min_temp or MINIMUM > settings.max_temp %}
	{ action_raise_error("MINIMUM must be between %.1f and %.1f" |
	format(settings.min_temp, settings.max_temp)) }
	{% elif MAXIMUM < settings.min_temp or MAXIMUM > settings.max_temp %}
	{ action_raise_error("MAXIMUM must be between %.1f and %.1f" |
	format(settings.min_temp, settings.max_temp)) }
	{% elif MINIMUM >= MAXIMUM %}
	{ action_raise_error("MINIMUM must be less than MAXIMUM.") }
	{% elif "TARGET" in params and (params.TARGET|float < MINIMUM or
	params.TARGET|float > MAXIMUM) %}
	{ action_raise_error("TARGET must be between %.1f and %.1f" |
	format(settings.min_temp, settings.max_temp)) }
	{% endif %}

[gcode_macro set_heater_scaling]
description = Sets scaling parameters for heater. If a new target temperature is
	passed it will be adjusted to the scaling parameters.
	Usage: SET_HEATER_SCALING [HEATER=<heater>] [SCALE=<scale_factor>]
	[BUMP=<degrees>] [MAXIMUM=<degrees>]
	[MINIMUM=<degrees>] [TARGET=<temp>]
variable_scaled_heaters = {}
gcode = 
	
	{% if "HEATER" is not in params %}
	{% set output = [] %}
	{% for h in scaled_heaters %}
	{% set dummy = output.append(
	"%s: Scale: %.2f Bump: %.1f Minimum:%.1f Maximum: %.1f"
	| format(h, scaled_heaters[h].scale, scaled_heaters[h].bump,
	scaled_heaters[h].minimum, scaled_heaters[h].maximum)) %}
	{% endfor %}
	{% if output %}}{action_respond_info(output|join('\n'))}{% endif %}
	{% else %}
	
	{% set HEATER = params.HEATER.lower() %}
	{% set settings = printer.configfile.settings[HEATER] %}
	{% if HEATER is not in scaled_heaters %}
	{% set dummy = scaled_heaters.__setitem__(HEATER, {"scale": 1.0,
	"bump": 0.0, "minimum": settings.min_temp,
	"maximum": settings.max_temp,
	"real_target": printer[HEATER].target}) %}
	{% endif %}
	_CHECK_HEATER_PARAMS{% for k in params %}{' '~k~'='~params[k]}{% endfor %}
	{% set scales = scaled_heaters[HEATER] %}
	{% set SCALE = params.SCALE|default(scales.scale)|float %}
	{% set BUMP = params.BUMP|default(scales.bump)|float %}
	{% set MAXIMUM = params.MAXIMUM|default(scales.maximum)|float %}
	{% set MINIMUM = params.MINIMUM|default(scales.minimum)|float %}
	{% set TARGET = params.TARGET|default(scales.real_target)|float %}
	{% set dummy = scales.__setitem__("scale", SCALE) %}
	{% set dummy = scales.__setitem__("bump", BUMP) %}
	{% set dummy = scales.__setitem__("maximum", MAXIMUM) %}
	{% set dummy = scales.__setitem__("minimum", MINIMUM) %}
	{% set dummy = scales.__setitem__("real_target", TARGET) %}
	
	{% set settings = printer.configfile.settings[HEATER] %}
	{% if SCALE != 1.0 or BUMP != 0.0 or MINIMUM != settings.min_temp or
	MAXIMUM != settings.max_temp %}
	{% set dummy = scaled_heaters.__setitem__(HEATER, scales) %}
	{% else %}
	{% set dummy = scaled_heaters.__delitem__(HEATER) %}
	{% endif %}
	SET_HEATER_TEMPERATURE_SCALED HEATER={HEATER} TARGET={TARGET}
	{action_respond_info(
	"%s: Scale: %.2f Bump: %.1f Minimum:%.1f Maximum: %.1f Target: %.1f"
	| format(HEATER, SCALE, BUMP, MINIMUM, MAXIMUM, TARGET))}
	{% endif %}
	
	{% set dummy = None if True else "
	{% set dummy = params.HEATER|default(e.g. extruder) %}
	{% set dummy = params.SCALE|default(1.0)|float %}
	{% set dummy = params.BUMP|default(0.0)|float %}
	{% set dummy = params.MAXIMUM|default(max_temp)|float %}
	{% set dummy = params.MINIMUM|default(min_temp)|float %}
	{% set dummy = params.TARGET|default(current target)|float %}
	" %}

[gcode_macro reset_heater_scaling]
description = Clears scaling for heater (or all heaters if none specified).
	Usage: RESET_HEATER_SCALING [HEATER=<heater>]
gcode = 
	{% if "HEATER" in params %}
	{% set HEATER = params.HEATER.lower() %}
	{% if HEATER not in printer.heaters.available_heaters %}
	{ action_raise_error("The value '%s' is not valid for HEATER"
	| format(HEATER)) }
	{% endif %}
	{% set settings = printer.configfile.settings[HEATER] %}
	SET_HEATER_SCALING HEATER={HEATER
	} SCALE=1.0 BUMP=0.0 MINIMUM={settings.min_temp
	} MAXIMUM={settings.max_temp}
	{% else %}
	
	SET_GCODE_VARIABLE MACRO=set_heater_scaling VARIABLE=scaled_heaters VALUE={
	"{}"}
	{% endif %}

[gcode_macro _km_idle_timeout]
gcode = 
	{% if printer.pause_resume.is_paused %}
	{action_respond_info("Extruder powered down on idle timeout.")}
	SET_GCODE_VARIABLE MACRO=resume VARIABLE=saved_extruder_temp VALUE="{
	printer[printer.toolhead.extruder].target}"
	M104; Turn off extruder but leave the bed on.
	{% else %}
	TURN_OFF_HEATERS
	M107; turn off fan
	M84
	_KM_PRINT_STATUS ACTION=CHANGE STATUS=ready
	{% endif %}

[gcode_macro _check_kinematic_limits]
gcode = 
	{% set toolhead = printer.toolhead %}
	{% if params.X and (params.X|float < toolhead.axis_minimum.x or
	params.X|float > toolhead.axis_maximum.x) %}
	{action_raise_error("X[%.3f] must be between %.3f and %.3f."
	| format(params.X|float, toolhead.axis_minimum.x,
	toolhead.axis_maximum.x))}
	{% elif params.Y and (params.Y|float < toolhead.axis_minimum.y or
	params.Y|float > toolhead.axis_maximum.y) %}
	{action_raise_error("Y[%.3f] must be between %.3f and %.3f."
	| format(params.Y|float, toolhead.axis_minimum.y,
	toolhead.axis_maximum.y))}
	{% elif params.Z and (params.Z|float < toolhead.axis_minimum.z or
	params.Z|float > toolhead.axis_maximum.z) %}
	{action_raise_error("Z[%.3f] must be between %.3f and %.3f."
	| format(params.Z|float, toolhead.axis_minimum.z,
	toolhead.axis_maximum.z))}
	{% elif params.E and (params.E|float|abs > printer.configfile.settings[
	"extruder"].max_extrude_only_distance) %}
	{action_raise_error("E[%.4f] exceeds max_extrude_only_distance[%.4f]."
	| format(params.E|float|abs, printer.configfile.settings[
	"extruder"].max_extrude_only_distance))}
	{% endif %}

[gcode_macro lazy_home]
description = Homes the specified axes. If lazy is true, already homed axes
	are skipped.
	Usage: LAZY_HOME [LAZY=<1|0>] [AXES=<axes_string>]
gcode = 
	
	LIST_MACROS SILENT=1
	_LAZY_HOME_INNER {rawparams}

[gcode_macro _lazy_home_inner]
gcode = 
	
	{% set G28 = (printer["gcode_macro list_macros"].macros.g28|
	default(["g28"],True))[-1] %}
	{% set axes = 'XYZ'|select('in', params.AXES|default("XYZ")|upper|list) %}
	{% if not axes %}
	{% set axes = 'XYZ' %}
	{% endif %}
	{% if params.LAZY|default(1)|int %}
	{% set axes = axes|reject('in', printer.toolhead.homed_axes|upper)|join() %}
	{% endif %}
	
	{% if axes %}
	_KM_PRINT_STATUS ACTION=PUSH_STATUS
	_KM_PRINT_STATUS ACTION=CHANGE STATUS=homing
	{G28}{% for k in axes %}{' ' ~ k}{% endfor %}
	_KM_PRINT_STATUS ACTION=CHANGE STATUS=pop_status
	{% endif %}

[gcode_macro g28]
description = Wraps the G28 command to add the Marlin "O" parameter so that
	already homed axes will not be homed again. See the Klipper documentation on
	G28 for the behavior of the other parameters.
	Usage: G28 [O] ...
rename_existing = G28.6245197
gcode = 
	{% set axes = 'XYZ'|select('in', params)|join() %}
	LAZY_HOME LAZY={('O' in params)|int}{%if axes%} AXES={axes}{%endif%}

[gcode_macro before_layer_change]
description = Add this to the "before layer change" input box in the slicer.
	Usage: BEFORE_LAYER_CHANGE HEIGHT=<current_height> LAYER=<current_layer>
gcode = 
	{% set height = params.HEIGHT|default(printer.toolhead.position.z)|float %}
	{% set layer = params.LAYER|default(-1)|int + 1 %}
	{% if height >= 0.0 and layer >= 0 %}
	SET_PRINT_STATS_INFO CURRENT_LAYER="{layer}"
	SET_GCODE_VARIABLE MACRO=_km_layer_run VARIABLE=cur_height VALUE="{height}"
	{% if printer["gcode_macro _km_layer_run"].clearance_z < height %}
	SET_GCODE_VARIABLE MACRO=_km_layer_run VARIABLE=clearance_z VALUE="{
	height}"
	{% endif %}
	{% endif %}

[gcode_macro after_layer_change]
description = Add this to the "after layer change" input box in the slicer.
	Usage: AFTER_LAYER_CHANGE
gcode = 
	_KM_LAYER_RUN

[gcode_macro gcode_at_layer]
description = Schedules the specified g-code command to be run at the specified
	layer. LAYER=next will cause the command to run at the next layer change.
	Usage: GCODE_AT_LAYER { HEIGHT=<pos> | LAYER=<layer> } COMMAND=<gcode>
	[CANCEL=<0|1>]
gcode = 
	{% set tot_layers = printer.print_stats.info.total_layer %}
	{% if params|length > 0 %}
	_KM_CHECK_IS_PRINTING
	
	{% set CANCEL = params.CANCEL|default(0)|int != 0 %}
	{% set COMMAND = params.COMMAND|default(None) %}
	{% if COMMAND %}
	{% set COMMAND = COMMAND.lstrip().split(None, 1) %}
	{% set COMMAND = " ".join([COMMAND[0]|upper] + COMMAND[1:]) %}
	{% endif %}
	
	{% if "LAYER" in params %}
	{% set cmd_container = "commands_layer" %}
	{% set cur_layer = printer.print_stats.info.current_layer|int %}
	{% if "HEIGHT" in params %}
	{action_raise_error("Conflicting HEIGHT and LAYER arguments provided.")}
	{% elif params.LAYER|string|lower == "next" %}
	{% set LAYER = cur_layer + 1 %}
	{% else %}
	{% set LAYER = params.LAYER|int %}
	{% endif %}
	{% if LAYER <= cur_layer %}
	{action_raise_error("LAYER[%i] must be above current print layer[%i]."
	| format(LAYER, cur_layer))}
	{% elif tot_layers and LAYER > tot_layers %}
	{action_raise_error("LAYER[%i] must not be above top layer[%i]."
	| format(LAYER, tot_layers))}
	{% endif %}
	{% set key = LAYER %}
	
	{% elif "HEIGHT" in params %}
	{% set cmd_container = "commands_height" %}
	{% set HEIGHT = params.HEIGHT|float %}
	{% set cur_height = printer["gcode_macro _km_layer_run"].cur_height %}
	{% if HEIGHT <= cur_height %}
	{action_raise_error(
	"HEIGHT[%.3f] must be above current print height[%.3f].")
	| format(HEIGHT, cur_height)}
	{% elif HEIGHT >= printer.toolhead.axis_maximum.z %}
	{action_raise_error(
	"HEIGHT[%.3f] must be below maximum Z height[%.3f].")
	| format(HEIGHT, printer.toolhead.axis_maximum.z)}
	{% endif %}
	{% set key = HEIGHT %}
	
	{% else %}
	{action_raise_error("No HEIGHT or LAYER argument provided.")}
	{% endif %}
	
	{% set commands = printer["gcode_macro _km_layer_run"][cmd_container] %}
	{% if key not in commands and not CANCEL %}
	{% set dummy = commands.__setitem__(key, []) %}
	{% endif %}
	
	{% if CANCEL %}
	{% if key in commands %}
	{% set pos = ("%i"|format(key)) if key is integer else
	("%.3fmm"|format(key)) %}
	{% if COMMAND %}
	{% set dummy = commands[key].remove(COMMAND) %}
	{% if commands[key]|length == 0 %}
	{% set dummy = commands.__delitem__(key) %}
	{% endif %}
	{action_respond_info("Cancelled %s %s:\n* %s" |
	format("layer" if k is integer else "height",
	pos, COMMAND))}
	{% else %}
	{% set dummy = commands.__delitem__(key) %}
	{action_respond_info("Cancelled all commands at %s %s." |
	format("layer" if k is integer else "height",
	pos))}
	{% endif %}
	{% endif %}
	{% elif not COMMAND %}
	{action_raise_error("No COMMAND argument provided.")}
	{% elif COMMAND in commands[key] %}
	{action_raise_error("Duplicate command previously scheduled.")}
	{% else %}
	{% set dummy = commands[key].append(COMMAND) %}
	{% set pos = ("%i"|format(key)) if key is integer else
	("%.3fmm"|format(key)) %}
	{action_respond_info("%s %s:\n* %s" |
	format("layer" if key is integer else "height",
	pos, COMMAND))}
	{% endif %}
	SET_GCODE_VARIABLE MACRO=_km_layer_run VARIABLE={cmd_container} VALUE="{
	commands|replace('\"','\\\"')}"
	_UPDATE_LAYER_COMPAT
	
	
	{% else %}
	{% set output = [] %}
	{% set commands = printer["gcode_macro _km_layer_run"].commands_layer %}
	{% for key in commands|list|sort %}
	{% set dummy = output.append("layer %i:" | format(key)) %}
	{% for c in commands[key] %}
	{% set dummy = output.append("* %s" | format(c)) %}
	{% endfor %}
	{% endfor %}
	{% set commands = printer["gcode_macro _km_layer_run"].commands_height %}
	{% for key in commands|list|sort %}
	{% set dummy = output.append("height %.3fmm:" | format(key)) %}
	{% for c in commands[key] %}
	{% set dummy = output.append("* %s" | format(c)) %}
	{% endfor %}
	{% endfor %}
	{action_respond_info(output|join('\n'))}
	{% endif %}

[gcode_macro _km_layer_run]
description = Runs pending commands for the current layer change.
	Usage: _KM_LAYER_RUN
variable_cur_height = 0.0
variable_clearance_z = 0.0
variable_commands_layer = {}
variable_commands_height = {}
gcode = 
	{% set cur_layer = printer.print_stats.info.current_layer %}
	{% for key in commands_layer | select("<=", cur_layer) | sort %}
	{action_respond_info("Executing scheduled commands at layer %d:\n%s" |
	format(key, commands_layer[key]|join('\n')))}
	{% for c in commands_layer[key] %}
	{c}
	{% endfor %}
	{% set dummy = commands_layer.__delitem__(key) %}
	{% endfor %}
	SET_GCODE_VARIABLE MACRO=_km_layer_run VARIABLE=commands_layer VALUE="{
	commands_layer|replace('\"','\\\"')}"
	{% for key in commands_height | select("<=", cur_height) | sort %}
	{action_respond_info("Executing scheduled commands at height %.3f:\n%s" |
	format(key, commands_height[key]|join('\n')))}
	{% for c in commands_height[key] %}
	{c}
	{% endfor %}
	{% set dummy = commands_height.__delitem__(key) %}
	{% endfor %}
	SET_GCODE_VARIABLE MACRO=_km_layer_run VARIABLE=commands_height VALUE="{
	commands_height|replace('\"','\\\"')}"
	_UPDATE_LAYER_COMPAT

[gcode_macro init_layer_gcode]
description = Clears scheduled gcode commands and state for all layers.
	Usage: INIT_LAYER_GCODE LAYERS=<num>
gcode = 
	SET_PRINT_STATS_INFO TOTAL_LAYER="{params.LAYERS|int + 1}" CURRENT_LAYER="{0}"
	SET_GCODE_VARIABLE MACRO=_km_layer_run VARIABLE=cur_height VALUE="{0.0}"
	SET_GCODE_VARIABLE MACRO=_km_layer_run VARIABLE=clearance_z VALUE="{0.0}"
	SET_GCODE_VARIABLE MACRO=_km_layer_run VARIABLE=commands_layer VALUE="{{}}"
	SET_GCODE_VARIABLE MACRO=_km_layer_run VARIABLE=commands_height VALUE="{{}}"
	_UPDATE_LAYER_COMPAT

[gcode_macro _reset_layer_gcode]
description = Clears scheduled gcode commands and state for all layers.
	Usage: _RESET_LAYER_GCODE
gcode = 
	SET_PRINT_STATS_INFO TOTAL_LAYER="{0}" CURRENT_LAYER="{0}"
	SET_GCODE_VARIABLE MACRO=_km_layer_run VARIABLE=cur_height VALUE="{0.0}"
	SET_GCODE_VARIABLE MACRO=_km_layer_run VARIABLE=clearance_z VALUE="{0.0}"
	SET_GCODE_VARIABLE MACRO=_km_layer_run VARIABLE=commands_layer VALUE="{{}}"
	SET_GCODE_VARIABLE MACRO=_km_layer_run VARIABLE=commands_height VALUE="{{}}"
	_UPDATE_LAYER_COMPAT

[gcode_macro cancel_all_layer_gcode]
description = Clears all scheduled gcode commands.
	Usage: CANCEL_ALL_LAYER_GCODE
gcode = 
	SET_GCODE_VARIABLE MACRO=_km_layer_run VARIABLE=commands_layer VALUE="{{}}"
	SET_GCODE_VARIABLE MACRO=_km_layer_run VARIABLE=commands_height VALUE="{{}}"
	_UPDATE_LAYER_COMPAT

[gcode_macro _update_layer_compat]
gcode = 
	{% set next_layer = printer.print_stats.info.current_layer|int + 1 %}
	{% set commands_layer = printer["gcode_macro _km_layer_run"].commands_layer %}
	{% set keys = commands_layer | sort(reverse=True) %}
	
	{% set pause_next_layer = {'enable': False, 'call':
	printer['gcode_macro SET_PRINT_STATS_INFO'].pause_next_layer.call} %}
	{% if pause_next_layer.call in commands_layer[next_layer] | default([]) %}
	{% set dummy = pause_next_layer.__setitem__('enable', True) %}
	{% endif %}
	SET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{
	pause_next_layer|replace('\"','\\\"') }"
	
	
	{% set pause_at_layer = {'enable': False, 'layer': 0, 'call':
	printer['gcode_macro SET_PRINT_STATS_INFO'].pause_at_layer.call} %}
	{% if pause_next_layer.enable and
	pause_next_layer.call == pause_at_layer.call %}
	{% set keys = keys | reject("==", next_layer) %}
	{% endif %}
	
	
	
	
	{% for key in keys %}
	{% if pause_at_layer.call in commands_layer[key] %}
	{% set dummy = pause_at_layer.__setitem__('enable', True) %}
	{% set dummy = pause_at_layer.__setitem__('layer', key) %}
	{% endif %}
	{% endfor %}
	SET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{
	pause_at_layer|replace('\"','\\\"') }"

[gcode_macro pause_next_layer]
description = Convenience macro to schedule the current print to pause at the
	next layer change. See PAUSE for additional arguments.
	Usage: PAUSE_NEXT_LAYER ...
gcode = 
	_CHECK_KINEMATIC_LIMITS{% for k in params%}{' ' ~k~ '=' ~ params[k]
	}{% endfor %}
	GCODE_AT_LAYER LAYER=NEXT COMMAND="PAUSE{% for k in params %}{
	' ' ~ k ~ '=' ~ params[k]}{% endfor %}"

[gcode_macro pause_at_layer]
description = Convenience macro to schedule the current print to pause at the
	specified layer change. LAYER=next will cause the command to run at the next
	layer change. See PAUSE for additional arguments.
	Usage: PAUSE_AT_LAYER { HEIGHT=<pos> | LAYER=<layer> } ...
gcode = 
	
	{% set dummy = None if True else "
	{% set dummy = params.LAYER|default(layer number)|float %}
	{% set dummy = params.HEIGHT|default(Z height)|int %}
	" %}
	{% set filtered_params = params|reject('in',['HEIGHT','LAYER'])|list|sort %}
	_CHECK_KINEMATIC_LIMITS{% for k in filtered_params%}{' ' ~k~ '=' ~ params[k]
	}{% endfor %}
	GCODE_AT_LAYER {% for k in params|select('in',['HEIGHT','LAYER'])|list %}{
	' ' ~ k ~ '=' ~ params[k] }{% endfor
	%} COMMAND="PAUSE{% for k in filtered_params %}{
	' ' ~ k ~ '=' ~ params[k]}{% endfor %}"

[gcode_macro speed_at_layer]
description = Convenience macro to schedule a feedrate adjustment at the
	specified layer change. LAYER=next will cause the command to run at the next
	layer change. (SPEED parameter behaves the same as the M220 S parameter.)
	Usage: SPEED_AT_LAYER { HEIGHT=<pos> | LAYER=<layer> } SPEED=<percentage>
gcode = 
	{% set SPEED = params.SPEED|default(0)|int %}
	{% if SPEED < 1 or SPEED > 500 %}
	{action_raise_error("SPEED[%i] parameter between 1 and 500 is required."
	% SPEED)}
	{% endif %}
	GCODE_AT_LAYER {% for k in params|select('in',['HEIGHT','LAYER'])|list %}{
	' ' ~ k ~ '=' ~ params[k] }{% endfor %} COMMAND="M220 S{SPEED|int}"
	
	{% set dummy = None if True else "
	{% set dummy = params.LAYER|default(layer number)|float %}
	{% set dummy = params.HEIGHT|default(Z height)|int %}
	{% set dummy = params.SPEED|default(percentage)|int %}
	" %}

[gcode_macro flow_at_layer]
description = Convenience macro to schedule a flow percentage adjustment at the
	specified layer change. LAYER=next will cause the command to run at the next
	layer change. (FLOW parameter behaves the same as the M221 S parameter.)
	Usage: FLOW_AT_LAYER { HEIGHT=<pos> | LAYER=<layer> } FLOW=<percentage>
gcode = 
	{% set FLOW = params.FLOW|default(0)|int %}
	{% if FLOW < 1 or FLOW > 500 %}
	{action_raise_error("FLOW[%i] parameter between 1 and 500 is required."
	% FLOW)}
	{% endif %}
	GCODE_AT_LAYER {% for k in params|select('in',['HEIGHT','LAYER'])|list %}{
	' ' ~ k ~ '=' ~ params[k] }{% endfor %} COMMAND="M221 S{FLOW|int}"
	
	{% set dummy = None if True else "
	{% set dummy = params.LAYER|default(layer number)|float %}
	{% set dummy = params.HEIGHT|default(Z height)|int %}
	{% set dummy = params.FLOW|default(percentage)|int %}
	" %}

[gcode_macro fan_at_layer]
description = Convenience macro to schedule a fan adjustment at the specified
	layer change. LAYER=next will cause the command to run at the next layer
	change. See SET_FAN_SCALING for additional arguments.
	Usage: FAN_AT_LAYER { HEIGHT=<pos> | LAYER=<layer> } ...
gcode = 
	
	{% set dummy = None if True else "
	{% set dummy = params.LAYER|default(layer number)|float %}
	{% set dummy = params.HEIGHT|default(Z height)|int %}
	{% set dummy = params.SCALE|default(1.0)|float %}
	{% set dummy = params.BUMP|default(0)|int %}
	{% set dummy = params.MAXIMUM|default(0)|int %}
	{% set dummy = params.MINIMUM|default(255)|int %}
	{% set dummy = params.SPEED|default(current speed)|int %}
	" %}
	{% set filtered_params = params|reject('in',['HEIGHT','LAYER'])|list|sort %}
	{% if filtered_params|length == 0 %}
	{action_raise_error("No fan parameters provided.")}
	{% endif %}
	_CHECK_FAN_PARAMS{% for k in filtered_params %}{' '~k~'='~params[k]
	}{% endfor %}
	GCODE_AT_LAYER {% for k in params|select('in',['HEIGHT','LAYER'])|list %}{
	' ' ~ k ~ '=' ~ params[k] }{% endfor
	%} COMMAND="SET_FAN_SCALING{% for k in filtered_params %}{
	' ' ~ k ~ '=' ~ params[k]}{% endfor %}"

[gcode_macro heater_at_layer]
description = Convenience macro to schedule a heater adjustment at the specified
	layer change. LAYER=next will cause the command to run at the next layer
	change. See SET_HEATER_SCALING for additional arguments.
	Usage: HEATER_AT_LAYER { HEIGHT=<pos> | LAYER=<layer> } ...
gcode = 
	
	{% set dummy = None if True else "
	{% set dummy = params.LAYER|default(layer number)|float %}
	{% set dummy = params.HEIGHT|default(Z height)|int %}
	{% set dummy = params.HEATER|default(e.g. extruder) %}
	{% set dummy = params.SCALE|default(1.0)|float %}
	{% set dummy = params.BUMP|default(0.0)|float %}
	{% set dummy = params.MAXIMUM|default(max_temp)|float %}
	{% set dummy = params.MINIMUM|default(min_temp)|float %}
	{% set dummy = params.TARGET|default(current target)|float %}
	" %}
	{% set filtered_params = params|reject('in',['HEIGHT','LAYER'])|list|sort %}
	_CHECK_HEATER_PARAMS{% for k in filtered_params%}{' ' ~ k ~ '=' ~ params[k]
	}{% endfor %}
	GCODE_AT_LAYER{% for k in params|select('in',['HEIGHT','LAYER'])|list %}{
	' ' ~ k ~ '=' ~ params[k] }{% endfor
	%} COMMAND="SET_HEATER_SCALING{% for k in filtered_params %}{
	' ' ~ k ~ '=\\\"' ~ params[k]|replace('\\','\\\\')|replace('\'','\\\'')
	|replace('\"','\\\"') ~ '\\\"'
	}{% endfor %}"

[gcode_macro park]
description = Park the toolhead
	Usage: PARK [P=<0|1|2>] [X=<pos>] [Y=<pos>] [Z=<pos>] [LAZY=<1|0>]
gcode = 
	{% set km = printer["gcode_macro _km_globals"] %}
	{% set LAZY = params.LAZY|default(1)|int %}
	{% if printer.toolhead.homed_axes != "xyz" %}
	{% if LAZY %}
	LAZY_HOME
	{% else %}
	{action_raise_error("Must home axes first.")}
	{% endif %}
	{% endif %}
	
	
	{% set P = (params.P|default(2))|int %}
	{% set X = params.X|default(km.park_x)|float %}
	{% set Y = params.Y|default(km.park_y)|float %}
	{% set Z = params.Z|default(km.park_z)|float %}
	
	M400
	_CHECK_KINEMATIC_LIMITS X="{X}" Y="{Y}" Z="{Z}"
	_PARK_INNER X="{X}" Y="{Y}" Z="{Z}" P="{P}" LAZY="{LAZY}"
	
	{% set dummy = None if True else "
	{% set dummy = params.P|default(mode=<0|1|2>)|int %}
	{% set dummy = params.X|default(X position)|int %}
	{% set dummy = params.Y|default(Y position)|int %}
	{% set dummy = params.Z|default(Z position)|int %}
	" %}

[gcode_macro _park_inner]
gcode = 
	{% set km = printer["gcode_macro _km_globals"] %}
	{% set travel_speed_xy = km.travel_speed_xy %}
	{% set travel_speed_z = km.travel_speed_z %}
	
	{% set position = printer.gcode_move.gcode_position %}
	{% set origin = printer.gcode_move.homing_origin%}
	
	
	
	{% set clearance_z = (printer["gcode_macro _km_layer_run"].clearance_z,
	position.z) | max %}
	{% set P = params.P|int %}
	{% set X = params.X|float - origin.x %}
	{% set Y = params.Y|float - origin.y %}
	{% set Z = params.Z|float %}
	{% set LAZY = params.LAZY|int %}
	
	
	{% if P == 0 %}
	{% if clearance_z > Z %}
	{% set Z = clearance_z %}
	{% endif %}
	{% elif P == 1 %}
	{% set Z = Z - origin.z %}
	{% elif P == 2 %}
	{% set Z = Z + clearance_z %}
	{% else %}
	{action_raise_error("Invalid parameter P=%i. Value must be 0, 1, or 2." |
	format(P)) }
	{% endif %}
	
	
	{% set Z = ((Z, printer.toolhead.axis_maximum.z - origin.z)|min,
	printer.toolhead.axis_minimum.z - origin.z)|max %}
	
	
	{% if (not LAZY) or P != 2 or X != position.x or Y != position.y
	or Z < clearance_z %}
	SAVE_GCODE_STATE NAME=_KM_PARK
	G90
	G0 Z{Z} F{travel_speed_z}
	G0 X{X} Y{Y} F{travel_speed_xy}
	RESTORE_GCODE_STATE NAME=_KM_PARK MOVE=0
	{% endif %}

[gcode_macro g27]
description = Parks the toolhead.
	Usage: G27 [P=<0|1|2>]
gcode = 
	
	PARK P={params.P|default(0)} {% for k in params|reject("in", "GP") %}{
	' '~k~'="'~params[k]~'"'
	}{% endfor %}

[gcode_macro pause]
description = Pauses the current print.
	Usage: PAUSE [X=<pos>] [Y=<pos>] [Z=<pos>] [E=<retract_length>] [B=<beeps>]
rename_existing = _KM_PAUSE_BASE
gcode = 
	{% set km = printer["gcode_macro _km_globals"] %}
	
	{% set E = (params.E|default(5))|float %}
	
	{% set B = params.B|default(10)|int if "output_pin beeper" in printer else 0
	%}
	
	{% if printer.pause_resume.is_paused %}
	{ action_respond_info("Print already paused") }
	{% elif printer.idle_timeout.state | string == "Printing" or
	(printer.virtual_sdcard|default({})).is_active|default(False) %}
	_KM_PRINT_STATUS ACTION=CHANGE STATUS=pausing RESET_STACK=1
	{% set position = printer.gcode_move.gcode_position %}
	SET_GCODE_VARIABLE MACRO=resume VARIABLE=saved_x VALUE="{position.x}"
	SET_GCODE_VARIABLE MACRO=resume VARIABLE=saved_y VALUE="{position.y}"
	SET_GCODE_VARIABLE MACRO=resume VARIABLE=saved_z VALUE="{position.z}"
	SET_GCODE_VARIABLE MACRO=resume VARIABLE=saved_e VALUE="{E}"
	SAVE_GCODE_STATE NAME=_KM_PAUSE_OVERRIDE_STATE
	_KM_PAUSE_BASE
	M83
	{% if printer.extruder.can_extrude %}
	G1 E{'%.4f' % -E} F{km.load_speed}
	{% endif %}
	PARK P=2{% for k in params|select("in", "XYZ") %}{
	' '~k~'="'~params[k]~'"'}{% endfor %}
	
	{% for i in range(B) %}
	M300 P100
	G4 P200
	{% endfor %}
	{% else %}
	{ action_respond_info("Print not in progress") }
	{% endif %}

[gcode_macro m600]
description = Pauses the current print.
	Usage: M600 [B<beeps>] [E<pos>] [L<pos>] [R<temp>] [U<pos>] [X<pos>] [Y<pos>]
	[Z<pos>]
gcode = 
	PAUSE B="{0}" P=2{% for k in params|select("in", "EXYZ") %}{
	' '~k~'="'~params[k]~'"'}{% endfor %}
	UNLOAD_FILAMENT{% if 'U' in params %} LENGTH={params.U}{% endif
	%} BEEPS="{params.B|default(10)|int}"
	{% if 'R' in params %}M109 S{params.R}{% endif %}

[gcode_macro m601]
description = Pauses the current print.
	Usage: M601
gcode = 
	PAUSE

[gcode_macro m602]
description = Resumes the currently paused print.
	Usage: M602
gcode = 
	RESUME

[gcode_macro m24]
rename_existing = M24.6245197
gcode = 
	{% if printer.pause_resume.is_paused %}
	RESUME
	{% else %}
	M24.6245197
	{% endif %}

[gcode_macro m25]
rename_existing = M25.6245197
gcode = 
	PAUSE

[gcode_macro resume]
description = Resumes the currently paused print.
	Usage: RESUME [E<pos>]
rename_existing = _KM_RESUME_BASE
variable_saved_extruder_temp = 0
variable_saved_x = 0.0
variable_saved_y = 0.0
variable_saved_z = 0.0
variable_saved_e = 0.0
gcode = 
	{% if printer.pause_resume.is_paused %}
	{% set km = printer["gcode_macro _km_globals"] %}
	
	{% set extruder = printer[printer.toolhead.extruder] %}
	{% if extruder.target <= printer.configfile.settings[
	printer.toolhead.extruder].min_temp
	| float + 0.5 %}
	M109 S{saved_extruder_temp}
	{% endif %}
	
	
	
	{% if 'E' not in params and not saved_e %}
	{% set saved_e = 5.0 %}
	G1 E{'%.4f' % -saved_e } F{km.load_speed}
	{% endif %}
	
	SET_GCODE_VARIABLE MACRO=resume VARIABLE=saved_extruder_temp VALUE="{0}"
	G90
	
	G0 X{saved_x} Y{saved_y} F{km.travel_speed_xy}
	G0 Z{saved_z} F{km.travel_speed_z}
	G91
	
	G1 E{'%.4f' % (params.E|default(saved_e))} F{km.load_speed}
	RESTORE_GCODE_STATE NAME=_KM_PAUSE_OVERRIDE_STATE MOVE=1
	_KM_RESUME_BASE
	{% else %}
	{ action_respond_info("Printer is not paused.") }
	{% endif %}
	_KM_PRINT_STATUS ACTION=CHANGE STATUS=printing RESET_STACK=1

[gcode_macro clear_pause]
description = Clears the current pause state.
	Usage: CLEAR_PAUSE
rename_existing = _KM_CLEAR_PAUSE
gcode = 
	SET_GCODE_VARIABLE MACRO=resume VARIABLE=saved_e VALUE="{0.0}"
	SET_GCODE_VARIABLE MACRO=resume VARIABLE=saved_extruder_temp VALUE="{0}"
	_KM_CLEAR_PAUSE

[gcode_macro print_start]
description = Inserted by slicer at start of print. Rather than using this macro
	directly you should configure your slicer as instructed in the readme.
	Usage: PRINT_START BED=<temp> EXTRUDER=<temp> [CHAMBER=<temp>]
	[MESH_MIN=<x,y>] [MESH_MAX=<x,y>] [LAYERS=<num>]
	[NOZZLE_SIZE=<mm>]
gcode = 
	{action_respond_info(
	"This file is using an old The PRINT_START format. This print will run "
	"fine, but you should update your slicer config to take advantage of the "
	"phased PRINT_START macros. The slicer documentation is here:\n"
	"https://github.com/jschuh/klipper-macros\x23slicer-configuration"
	)}
	
	_PRINT_START_PHASE_INIT {rawparams}
	_PRINT_START_PHASE_PREHEAT
	_PRINT_START_PHASE_PROBING
	_PRINT_START_PHASE_EXTRUDER
	_PRINT_START_PHASE_PURGE

[gcode_macro _print_start_phase_init]
description = Inserted by slicer at start of print. Initializes PRINT_START
	phases.
	Usage: See PRINT_START.
gcode = 
	CHECK_KM_CONFIG
	SET_GCODE_VARIABLE MACRO=_print_end_inner VARIABLE=cancelled VALUE="{False}"
	_KM_APPLY_PRINT_OFFSET RESET=1
	_PRINT_START_PHASE_CHECK PHASE=none
	{% set km = printer["gcode_macro _km_globals"] %}
	
	{% if not params.BED %}
	{% set dummy = params.__setitem__('BED', params.BED_TEMP|int) %}
	{% endif %}
	{% if not params.EXTRUDER %}
	{% set dummy = params.__setitem__('EXTRUDER', params.EXTRUDER_TEMP|int) %}
	{% endif %}
	
	
	PRINT_START_SET PRINT_START_PHASE="init" {% for k in params %}{' %s=\"%s\"' %
	(k,params[k]|replace('\\','\\\\')|replace('\'','\\\'')|replace('\"','\\\"'))
	}{% endfor %}
	
	
	_km_check_and_set_print_bounds
	
	M107
	CLEAR_PAUSE
	
	M140 S{params.BED}
	{% if params.CHAMBER %}M141 S{params.CHAMBER|int}{% endif %}
	{% if printer.bed_mesh %}BED_MESH_CLEAR{% endif %}
	
	{% if km.start_try_saved_surface_mesh and printer.bed_mesh %}
	LOAD_SURFACE_MESH
	{% endif %}
	PRINT_START_SET PRINT_START_PHASE="preheat"

[gcode_macro _print_start_phase_preheat]
description = Inserted by slicer at start of print. Handles the bed and chamber
	heating phases and ends when both are stabilized at their target temperatures.
	Usage: See PRINT_START.
gcode = 
	_PRINT_START_PHASE_CHECK PHASE=preheat
	{% set print = printer["gcode_macro print_start_set"].print %}
	{% set BED = print.BED|int %}
	{% set EXTRUDER = print.EXTRUDER|int %}
	{% set CHAMBER = print.CHAMBER|default(0)|int %}
	{% set LAYERS = print.LAYERS|default(0)|int %}
	{% set km = printer["gcode_macro _km_globals"] %}
	
	{% set bed_at_target = (BED + 0.4 - printer.heater_bed.temperature) |
	abs <= 0.6 %}
	PRINT_START_SET BED_AT_TARGET={1 if bed_at_target else 0}
	{% set start_level_bed_at_temp = km.start_level_bed_at_temp and
	not printer.bed_mesh.profile_name %}
	{% set actions_at_temp = start_level_bed_at_temp or
	km.start_quad_gantry_level_at_temp or
	km.start_z_tilt_adjust_at_temp or
	(km.start_home_z_at_temp and not bed_at_target) %}
	{% set bed_overshoot = (BED + (km.start_bed_heat_overshoot if
	(BED and not bed_at_target) else 0.0),
	printer.configfile.settings.heater_bed.max_temp ) | min %}
	
	INIT_LAYER_GCODE LAYERS="{LAYERS}"
	{% if CHAMBER > 0.0 %}
	M141 S{CHAMBER}
	{% endif %}
	
	M140 S{bed_overshoot}
	{% if actions_at_temp %}
	
	
	M104 S{km.start_extruder_probing_temp if km.start_extruder_probing_temp > 0
	else (km.start_extruder_preheat_scale * EXTRUDER)|round(0,'ceil')|int}
	{% else %}
	M104 S{EXTRUDER}
	{% endif %}
	
	_KM_PRINT_STATUS ACTION=CHANGE STATUS=homing RESET_STACK=1
	G28
	G90
	{% if BED > 0.0 %}
	_KM_PRINT_STATUS ACTION=CHANGE STATUS=bed_heating RESET_STACK=1
	
	{% if not bed_at_target %}
	PARK
	
	M190 S{bed_overshoot}
	G4 P{km.start_bed_heat_delay / 2}
	M190 R{BED}
	G4 P{km.start_bed_heat_delay / 2}
	{% endif %}
	{% endif %}
	
	{% if CHAMBER > 0.0 %}
	_KM_PRINT_STATUS ACTION=CHANGE STATUS=chamber_heating RESET_STACK=1
	_KM_PARK_IF_NEEDED HEATER="chamber" RANGE=ABOVE
	M191 S{CHAMBER}
	{% endif %}
	
	{% if BED > 0.0 and bed_at_target%}
	M190 R{BED}
	{% endif %}
	PRINT_START_SET PRINT_START_PHASE="probing"

[gcode_macro _print_start_phase_probing]
description = Inserted by slicer at start of print. Performs probing (including
	mesh bed level) and other operations that should be run when the bed and
	chamber are stabilized at their target temps.
	Usage: See PRINT_START.
gcode = 
	_PRINT_START_PHASE_CHECK PHASE=probing
	{% set print = printer["gcode_macro print_start_set"].print %}
	{% set km = printer["gcode_macro _km_globals"] %}
	{% set MESH_MIN = print.MESH_MIN|default(None) %}
	{% set MESH_MAX = print.MESH_MAX|default(None) %}
	
	{% if km.start_random_placement_max > 0 and print.PRINT_MIN and MESH_MIN %}
	{% set PRINT_MIN = print.PRINT_MIN.split(",")|map('float')|list %}
	{% set PRINT_MAX = print.PRINT_MAX.split(",")|map('float')|list %}
	{% set x_offset = (((km.print_max[0] - km.print_min[0] - PRINT_MAX[0] +
	PRINT_MIN[0] - 2 * km.start_random_placement_padding)|int,
	km.start_random_placement_max * 2)|min, 0)|max %}
	{% set y_offset = (((km.print_max[1] - km.print_min[1] - PRINT_MAX[1] +
	PRINT_MIN[1] - 2 * km.start_random_placement_padding)|int,
	km.start_random_placement_max * 2)|min, 0)|max %}
	{% if x_offset > 0 %}
	{% set x_offset = range(x_offset)|random + km.print_min[0] -
	PRINT_MIN[0] + km.start_random_placement_padding %}
	{% endif %}
	{% if y_offset > 0 %}
	{% set y_offset = range(y_offset)|random + km.print_min[1] -
	PRINT_MIN[1] + km.start_random_placement_padding %}
	{% endif %}
	
	
	{% set MESH_MIN = MESH_MIN.split(",")|map('float')|list %}
	{% set MESH_MAX = MESH_MAX.split(",")|map('float')|list %}
	{% set MESH_MIN_NEW = (MESH_MIN[0] + x_offset, MESH_MIN[1] + y_offset) %}
	{% set MESH_MAX_NEW = (MESH_MAX[0] + x_offset, MESH_MAX[1] + y_offset) %}
	{action_respond_info(
	"Relocating print origin from (%.3f,%.3f) "|format(*MESH_MIN) +
	"to (%.3f,%.3f)"|format(*MESH_MIN_NEW))}
	{% set MESH_MIN = (MESH_MIN_NEW[0], MESH_MIN_NEW[1])|join(',') %}
	{% set MESH_MAX = (MESH_MAX_NEW[0], MESH_MAX_NEW[1])|join(',') %}
	PRINT_START_SET PRINT_OFFSET={"%d,%d" % (x_offset,y_offset)}
	{% endif %}
	
	{% set EXTRUDER = print.EXTRUDER|int %}
	{% set km = printer["gcode_macro _km_globals"] %}
	{% set start_level_bed_at_temp = km.start_level_bed_at_temp and
	not printer.bed_mesh.profile_name %}
	{% set start_home_z_at_temp = km.start_home_z_at_temp and
	not print.BED_AT_TARGET|int %}
	{% set actions_at_temp = start_level_bed_at_temp or
	km.start_quad_gantry_level_at_temp or
	km.start_z_tilt_adjust_at_temp or
	start_home_z_at_temp %}
	{% if actions_at_temp %}
	{% if km.start_extruder_probing_temp > 0 %}
	_KM_PRINT_STATUS ACTION=CHANGE STATUS=extruder_heating RESET_STACK=1
	_KM_PARK_IF_NEEDED HEATER={printer.toolhead.extruder} RANGE=2
	M109 R{km.start_extruder_probing_temp}
	{% else %}
	M104 S{EXTRUDER}
	{% endif %}
	{% if start_home_z_at_temp %}
	_KM_PRINT_STATUS ACTION=CHANGE STATUS=homing RESET_STACK=1
	G28 Z
	{% endif %}
	{% if km.start_z_tilt_adjust_at_temp %}
	_KM_PRINT_STATUS ACTION=CHANGE STATUS=calibrating_z RESET_STACK=1
	Z_TILT_ADJUST
	{% endif %}
	{% if km.start_quad_gantry_level_at_temp %}
	_KM_PRINT_STATUS ACTION=CHANGE STATUS=leveling_gantry RESET_STACK=1
	QUAD_GANTRY_LEVEL
	{% endif %}
	{% if start_level_bed_at_temp %}
	_KM_PRINT_STATUS ACTION=CHANGE STATUS=meshing RESET_STACK=1
	_km_mesh_if_needed {% if MESH_MIN %} MESH_MIN={MESH_MIN}{% endif
	%}{% if MESH_MAX %} MESH_MAX={MESH_MAX}{% endif %}
	{% endif %}
	{% if km.start_extruder_probing_temp > 0 %}
	M104 S{EXTRUDER}
	{% endif %}
	G4
	{% endif %}
	PRINT_START_SET PRINT_START_PHASE="extruder"

[gcode_macro _print_start_phase_extruder]
description = Inserted by slicer at start of print. Preheats the extruder.
	Usage: See PRINT_START.
gcode = 
	_PRINT_START_PHASE_CHECK PHASE=extruder
	{% set print = printer["gcode_macro print_start_set"].print %}
	{% set EXTRUDER = print.EXTRUDER|default(print.EXTRUDER_TEMP)|float %}
	{% set km = printer["gcode_macro _km_globals"] %}
	
	
	{% if EXTRUDER > 0 %}
	_KM_PRINT_STATUS ACTION=CHANGE STATUS=extruder_heating RESET_STACK=1
	_KM_PARK_IF_NEEDED HEATER={printer.toolhead.extruder} RANGE=ABOVE
	M109 S{EXTRUDER}
	{% endif %}
	PRINT_START_SET PRINT_START_PHASE="purge"

[gcode_macro _print_start_phase_purge]
description = Inserted by slicer at start of print. Generates purge lines.
	Usage: See PRINT_START.
gcode = 
	_PRINT_START_PHASE_CHECK PHASE=purge
	
	_KM_APPLY_PRINT_OFFSET
	
	_APPLY_BED_SURFACE_OFFSET
	{% set print = printer["gcode_macro print_start_set"].print %}
	{% set MESH_MIN = print.MESH_MIN|default(None) %}
	{% set MESH_MAX = print.MESH_MAX|default(None) %}
	{% set NOZZLE_SIZE = print.NOZZLE_SIZE|default(print.NOZZLE_SIZE)|
	default(printer.configfile.settings.extruder.nozzle_diameter)|float %}
	{% set km = printer["gcode_macro _km_globals"] %}
	{% if km.start_purge_length > 0.0 and printer.extruder.can_extrude %}
	_KM_PRINT_STATUS ACTION=CHANGE STATUS=purging RESET_STACK=1
	DRAW_PURGE_LINE WIDTH="{NOZZLE_SIZE * 1.25}" HEIGHT="{NOZZLE_SIZE * 0.625
	}"{% if MESH_MIN %} PRINT_MIN={MESH_MIN}{% endif
	%}{% if MESH_MAX %} PRINT_MAX={MESH_MAX}{% endif %}
	{% endif %}
	PRINT_START_SET PRINT_START_PHASE="printing"
	_KM_PRINT_STATUS ACTION=CHANGE STATUS=printing RESET_STACK=1

[gcode_macro _km_park_if_needed]
description = Parks the extruder if the current temperature of the supplied
	heater is not within the specified target range.
	Usage: _KM_PARK_IF_NEEDED HEATER=<heater> RANGE=[<percentage>|ABOVE|BELOW]
gcode = 
	
	{% set HEATER = params.HEATER if params.HEATER in
	printer.heaters.available_heaters else
	("heater_generic " ~ params.HEATER) %}
	{% set RANGE = (params.RANGE|default(1))|string|upper %}
	
	{% if printer[HEATER].target %}
	{% if RANGE == "ABOVE" %}
	{% if printer[HEATER].temperature < printer[HEATER].target %}
	PARK
	{% endif %}
	{% elif RANGE == "BELOW" %}
	{% if printer[HEATER].temperature > printer[HEATER].target %}
	PARK
	{% endif %}
	{% elif (printer[HEATER].temperature - printer[HEATER].target)|abs >
	(printer[HEATER].target * RANGE|float * 0.01)|abs %}
	PARK
	{% endif %}
	{% endif %}

[gcode_macro _km_apply_print_offset]
variable_offset = []
gcode = 
	{% set print = printer["gcode_macro print_start_set"].print %}
	{% if params.RESET|default(0)|int and offset and
	not printer["gcode_macro _km_save_state"].is_ephemeral%}
	{% set PRINT_OFFSET = [offset.pop(0) * -1, offset.pop() * -1] %}
	{% elif print.PRINT_OFFSET and not offset and
	not printer["gcode_macro _km_save_state"].is_ephemeral %}
	{% set PRINT_OFFSET = print.PRINT_OFFSET.split(",")|map('float')|list %}
	{% set dummy = offset.extend(PRINT_OFFSET) %}
	{% endif %}
	
	{% if PRINT_OFFSET %}
	_KM_SET_GCODE_OFFSET_BASE {"X_ADJUST=%.2f Y_ADJUST=%.2f"|
	format(*PRINT_OFFSET)}
	{% endif %}

[gcode_macro _km_mesh_if_needed]
gcode = 
	
	
	
	{% if not printer.bed_mesh.profile_name %}
	BED_MESH_CALIBRATE_FAST {rawparams}
	{% endif %}

[gcode_macro print_start_set]
description = Inserted by slicer to set values used by PRINT_START.
	Usage: PRINT_START_SET <VARIABLE>=<value>
variable_print = {}
gcode = 
	{%for k in params %}
	{% set dummy = print.__setitem__(k|upper, params[k]) %}
	{% endfor %}

[gcode_macro _print_start_phase_check]
gcode = 
	{% set print = printer["gcode_macro print_start_set"].print %}
	{% set PRINT_START_PHASE = print.PRINT_START_PHASE|default("none") %}
	{% if PRINT_START_PHASE != params.PHASE %}
	
	SET_GCODE_VARIABLE MACRO=print_start_set VARIABLE=print VALUE="{{}}"
	{% if params.PHASE != 'none' %}
	{% set error = "PRINT_START phase error. Expected '%s' but found '%s'" %
	(params.PHASE, PRINT_START_PHASE) %}
	
	{% if not 'virtual_sdcard' in printer or
	not printer.virtual_sdcard.is_active or 'CANCEL_PRINT' not in
	printer.configfile.settings.virtual_sdcard.on_error_gcode|
	default("")|upper %}
	{action_respond_info(error)}
	CANCEL_PRINT
	{% else %}
	{action_raise_error(error)}
	{% endif %}
	{% else %}
	{ action_respond_info("Expected phase '%s' but found '%s'. Resetting."
	% (params.PHASE, PRINT_START_PHASE)) }
	{% endif %}
	{% endif %}

[gcode_macro print_end]
description = Inserted by slicer at end of print.
	Usage: PRINT_END
gcode = 
	_KM_CHECK_IS_PRINTING
	M400
	_PRINT_END_INNER
	
	{% set km = printer["gcode_macro _km_globals"] %}
	
	{% if km.start_clear_adjustments_at_end != 0 %}
	RESET_HEATER_SCALING
	RESET_FAN_SCALING
	M220 S100
	M221 S100
	{% endif %}
	_RESET_LAYER_GCODE
	_RESET_VELOCITY_LIMITS
	TURN_OFF_HEATERS
	M107; turn off fan
	{% if printer.bed_mesh %}BED_MESH_CLEAR{% endif %}
	
	{% if printer.toolhead.homed_axes|lower == "xyz" %}
	PARK Y="{km.start_end_park_y}"
	{% endif %}
	M84
	CLEAR_PAUSE
	SET_GCODE_VARIABLE MACRO=print_start_set VARIABLE=print VALUE="{{}}"
	_KM_PRINT_STATUS ACTION=CHANGE STATUS=ready RESET_STACK=1

[gcode_macro _print_end_inner]
variable_cancelled = False
gcode = 
	SET_GCODE_VARIABLE MACRO=_print_end_inner VARIABLE=cancelled VALUE="{False}"
	{% set km = printer["gcode_macro _km_globals"] %}
	{% set toolhead = printer.toolhead %}
	{% set origin = printer.gcode_move.homing_origin%}
	{% set max_x = km.print_max[0] - origin.x %}
	{% set max_y = km.print_max[1] - origin.y %}
	{% set max_z = toolhead.axis_maximum.z - origin.z %}
	
	{% if not cancelled %}
	_KM_PRINT_STATUS ACTION=CHANGE STATUS=completing
	{% endif %}
	
	{% if printer.extruder.can_extrude %}
	
	{% if not printer.pause_resume.is_paused and not cancelled and
	toolhead.homed_axes|lower == "xyz" %}
	{% set x_safe = (max_x - toolhead.position.x, 2.0)|min %}
	{% set y_safe = (max_y - toolhead.position.y, 2.0)|min %}
	{% set z_safe = (max_z - toolhead.position.z, 2.0)|min %}
	G91
	G0 Z{z_safe} E-1.0 F{km.travel_speed_z * 2}
	G0 X{x_safe} Y{y_safe} E-1.0 F{km.travel_speed_xy}
	
	_KM_APPLY_PRINT_OFFSET RESET=1
	{% endif %}
	
	
	G92 E0
	G1 E-5.0 F3600
	M400
	{% endif %}

[gcode_macro _km_check_is_printing]
variable_debug_state = False
description = Throws an error if print is not currently in progress.
gcode = 
	{% if not debug_state and
	printer.idle_timeout.state|string != "Printing" and
	not (printer.virtual_sdcard|default({})).is_active|default(False) and
	not printer.pause_resume.is_paused %}
	{ action_raise_error("No active print.") }
	{% endif %}

[gcode_macro _km_check_and_set_print_bounds]
description = Validates all print bounds and caches their values.
gcode = 
	{% set km = printer["gcode_macro _km_globals"] %}
	{% set print = printer["gcode_macro print_start_set"].print %}
	
	
	{% if print.MESH_MIN %}
	{% set MESH_MIN = print.MESH_MIN.split(",")|map('float')|list %}
	{% set MESH_MAX = print.MESH_MAX.split(",")|map('float')|list %}
	{%if MESH_MIN[0] < km.print_min[0] or MESH_MIN[1] < km.print_min[1] %}
	{action_raise_error("MESH_MIN %s is outside the printable bounds" %
	(MESH_MIN|string, km.print_min|string))}
	{%elif MESH_MAX[0] > km.print_max[0] or MESH_MAX[1] > km.print_max[1] %}
	{action_raise_error("MESH_MAX %s is outside the printable bounds %s" %
	(MESH_MAX|string, km.print_max|string))}
	{% endif %}
	{% endif %}
	
	
	{% set points = [] %}
	{% if print.MODEL_MIN or print.MODEL_MAX %}
	{% set MODEL_MIN = print.MODEL_MIN.split(",")|map('float')|list %}
	{% set MODEL_MAX = print.MODEL_MAX.split(",")|map('float')|list %}
	{% set points = [MODEL_MIN, MODEL_MAX] %}
	{% endif %}
	{% if (printer.exclude_object|default({})).objects %}
	{% set points = printer.exclude_object.objects|selectattr('polygon')|
	map(attribute='polygon')|sum(start=points) %}
	{% set points_len = points|length %}
	{% if points_len >= 2 %}
	{% set x_coords = (points|map(attribute=0)|sort|list)[0::points_len-1] %}
	{% set y_coords = (points|map(attribute=1)|sort|list)[0::points_len-1] %}
	{% set MODEL_MIN = (x_coords[0],y_coords[0])|map('float')|list %}
	{% set MODEL_MAX = (x_coords[1],y_coords[1])|map('float')|list %}
	PRINT_START_SET MODEL_MIN="{MODEL_MIN|join(',')
	}" MODEL_MAX="{MODEL_MAX|join(',')}"
	{% endif %}
	{% endif %}
	
	{% if MODEL_MIN %}
	
	{% if MODEL_MIN[0] < km.print_min[0] or MODEL_MIN[1] < km.print_min[1] %}
	{action_raise_error("MODEL_MIN %s is outside the printable bounds" %
	(MODEL_MIN|string, km.print_min|string))}
	{% elif MODEL_MAX[0] > km.print_max[0] or MODEL_MAX[1] > km.print_max[1] %}
	{action_raise_error("MODEL_MAX %s is outside the printable bounds %s" %
	(MODEL_MAX|string, km.print_max|string))}
	{% endif %}
	{% endif %}
	
	
	{% if MESH_MIN and MODEL_MIN %}
	PRINT_START_SET PRINT_MIN="{((MODEL_MIN[0],MESH_MIN[0])|min,
	(MODEL_MIN[1],MESH_MIN[1])|min)|join(',')
	}" PRINT_MAX="{((MODEL_MAX[0],MESH_MAX[0])|max,
	(MODEL_MAX[1],MESH_MAX[1])|max)|join(',')}"
	{% else %}
	PRINT_START_SET PRINT_MIN="{km.print_min|join(',')
	}" PRINT_MAX="{km.print_max|join(',')}"
	{% endif %}

[gcode_macro _km_save_state]
description = Tracks gcode state.
variable_state_set = {}
variable_is_ephemeral = 0
gcode = 
	{% if params.SAVE|int %}
	{% set dummy = state_set.__setitem__(params.NAME, None) %}
	{% else %}
	{% set dummy = state_set.__delitem__(params.NAME) %}
	{% endif %}
	SET_GCODE_VARIABLE MACRO=_km_save_state VARIABLE=is_ephemeral VALUE="{
	1 if state_set|length > 0 else 0 }"

[gcode_macro save_gcode_state]
description = Wraps SAVE_GCODE_STATE to track persistence state.
	Usage: See Klipper documentation
rename_existing = _KM_SAVE_GCODE_STATE
gcode = 
	_KM_SAVE_GCODE_STATE {rawparams}
	{% set NAME = params.NAME|default("default") %}
	_km_save_state NAME={NAME} SAVE=1

[gcode_macro restore_gcode_state]
description = Wraps RESTORE_GCODE_STATE to track persistence state.
	Usage: See Klipper documentation
rename_existing = _KM_RESTORE_GCODE_STATE
gcode = 
	_KM_RESTORE_GCODE_STATE {rawparams}
	{% set NAME = params.NAME|default("default") %}
	_km_save_state NAME={NAME} SAVE=0

[gcode_macro _abort_on_gcode_state]
gcode = 
	{% set save_state = printer["gcode_macro _km_save_state"] %}
	{% if save_state.is_ephemeral %}
	{action_raise_error("Encountered unexpected save state " +
	save_state.state_set|list|sort|string)}
	{% endif %}

[gcode_macro _km_print_status]
variable_last_status = 'none'
variable_status_stack = []
variable_command_list = {}
variable_status_list = [
	'ready',
	'filament_load',
	'filament_unload',
	'bed_heating',
	'chamber_heating',
	'homing',
	'leveling_gantry',
	'calibrating_z',
	'meshing',
	'extruder_heating',
	'purging',
	'printing',
	'pausing',
	'cancelling',
	'completing',
	]
gcode = 
	{% set ACTION = params.ACTION|trim|upper %}
	{% set STATUS = params.STATUS|default("")|trim|lower %}
	
	
	{% if ACTION == "ADD_EVENT" %}
	{% set COMMAND = params.COMMAND %}
	{% set ARGS = params.ARGS|default(0)|int != 0 %}
	{% set TYPE = params.TYPE|default('ENTER')|trim|upper %}
	{% set WHEN = params.WHEN|default('PRINTING')|trim|upper %}
	{% set FILTER_ENTER =
	(params.FILTER_ENTER|default("")|trim|lower).split(',')|
	select()|unique|list %}
	{% set FILTER_LEAVE =
	(params.FILTER_LEAVE|default("")|trim|lower).split(',')|
	select()|unique|list %}
	
	{% set STATUSES = STATUS.split(',')|map('trim')|list %}
	{% for s in (STATUSES if STATUSES[0] != 'all' else status_list) %}
	{% if not s in command_list %}
	{% set dummy = command_list.__setitem__(s,[]) %}
	{% endif %}
	{% set dummy = command_list[s].append({'cmd':COMMAND, 'args':ARGS,
	'type':TYPE, 'when':WHEN,
	'filt_e':FILTER_ENTER,
	'filt_l':FILTER_LEAVE}) %}
	{% endfor %}
	
	
	{% elif ACTION == "CHANGE" %}
	{% if params.RESET_STACK|default(0)|int %}
	{% for dummy in range(status_stack|length) %}
	{% set dummy = status_stack.pop() %}
	{% endfor %}
	
	
	{% elif STATUS == "pop_status" %}
	{% set STATUS = (status_stack|default(['ready'], True)).pop() %}
	{% endif %}
	
	{% if STATUS not in status_list %}
	{action_raise_error("Status '%s' not valid."|format(STATUS))}
	{% endif %}
	
	{% if STATUS != last_status %}
	{% set is_printing =
	printer["gcode_macro print_start_set"].print.PRINT_START_PHASE|
	default("")|length != 0 %}
	{% set print_states = ('ALWAYS', 'PRINTING' if is_printing else 'IDLE') %}
	
	{% for c in command_list[last_status]|default([]) %}
	{% if c.type in ('BOTH','LEAVE') and c.when in print_states and
	(not c.filt_l or STATUS in c.filt_l) %}
	M400
	{c.cmd}{% if c.args %} TYPE=LEAVE WHEN={print_states[1]
	} LAST_STATUS={last_status} NEXT_STATUS={STATUS}{% endif %}
	{% endif %}
	{% endfor %}
	
	{% for c in command_list[STATUS]|default([]) %}
	{% if c.type in ('BOTH','ENTER') and c.when in print_states and
	(not c.filt_e or STATUS in c.filt_e) %}
	M400
	{c.cmd}{% if c.args %} TYPE=ENTER WHEN={print_states[1]
	} LAST_STATUS={last_status} NEXT_STATUS={STATUS}{% endif %}
	{% endif %}
	{% endfor %}
	SET_GCODE_VARIABLE MACRO=_km_print_status VARIABLE=last_status VALUE="'{
	STATUS}'"
	{% endif %}
	
	
	{% elif ACTION == "PUSH_STATUS" %}
	{% set dummy = status_stack.append(last_status) %}
	
	
	{% else %}
	{action_raise_error("Action '%s' not valid."|format(ACTION))}
	{% endif %}

[gcode_macro gcode_on_print_status]
description = Adds a gcode command for a status event.
	Usage: GCODE_ON_PRINT_STATUS STATUS=<status> COMMAND=<gcode> [ARGS=<1|0>]
	[WHEN=<PRINTING|IDLE|ALWAYS>]
	[TYPE=<ENTER|LEAVE|BOTH>]
	[FILTER_ENTER=<status list>]
	[FILTER_LEAVE=<status list>]
gcode = 
	{% set STATUS = (params.STATUS|lower).split(',')|map('trim')|list %}
	{% set TYPE = params.TYPE|default('ENTER')|trim|upper %}
	{% set WHEN = params.WHEN|default('PRINTING')|trim|upper %}
	{% set FILTER_ENTER =
	(params.FILTER_ENTER|default("")|trim|lower).split(',')|select()|list %}
	{% set FILTER_LEAVE =
	(params.FILTER_LEAVE|default("")|trim|lower).split(',')|select()|list %}
	
	
	{% set status_list = printer["gcode_macro _km_print_status"].status_list %}
	{% for s in STATUS %}
	{% if not (s in status_list or s == 'all' and STATUS|length == 1) %}
	{action_raise_error("STATUS parameter '%s' not valid."|format(s))}
	{% endif %}
	{% endfor %}
	
	{% if TYPE not in ('ENTER', 'LEAVE', 'BOTH') %}
	{action_raise_error("TYPE paramater '%s' not valid."|format(TYPE))}
	{% elif WHEN not in ('PRINTING', 'IDLE', 'ALWAYS') %}
	{action_raise_error("WHEN parameter '%s' not valid."|format(WHEN))}
	{% elif TYPE == 'ENTER' and FILTER_LEAVE %}
	{action_raise_error("FILTER_LEAVE not valid with TYPE=ENTER.")}
	{% elif TYPE == 'LEAVE' and FILTER_ENTER %}
	{action_raise_error("FILTER_ENTER not valid with TYPE=LEAVE.")}
	{% endif %}
	{% for f in FILTER_ENTER %}
	{% if f not in status_list %}
	{action_raise_error("FILTER_ENTER parameter '%s' not valid."|format(f))}
	{% endif %}
	{% endfor %}
	{% for f in FILTER_LEAVE %}
	{% if f not in status_list %}
	{action_raise_error("FILTER_LEAVE parameter '%s' not valid."|format(f))}
	{% endif %}
	{% endfor %}
	
	
	_KM_PRINT_STATUS ACTION=ADD_EVENT {rawparams}

[gcode_macro m201]
description = Sets maximum accelleration.
	Usage: M201 [X<accel>] [Y<accel>]
variable_max_accel = 1.7976931348623157e+308
gcode = 
	{% set km = printer["gcode_macro _km_globals"] %}
	{% if 'X' in params or 'Y' in params %}
	{% set accel = (params.X|default(params.Y)|float,
	params.Y|default(params.X)|float)|min %}
	SET_GCODE_VARIABLE MACRO=m201 VARIABLE=max_accel VALUE="{accel}"
	{% else %}
	SET_VELOCITY_LIMIT
	{% endif %}

[gcode_macro m203]
description = Sets maximum velocity.
	Usage: M203 [X<velocity>] [Y<velocity>]
gcode = 
	{% if 'X' in params or 'Y' in params %}
	{% set velocity = (params.X|default(params.Y)|float,
	params.Y|default(params.X)|float)|min %}
	SET_VELOCITY_LIMIT VELOCITY="{velocity}"
	{% else %}
	SET_VELOCITY_LIMIT
	{% endif %}

[gcode_macro m205]
description = Sets square corner velocity.
	Usage: M203 [X<velocity>] [Y<velocity>]
gcode = 
	{% if 'X' in params or 'Y' in params %}
	SET_VELOCITY_LIMIT SQUARE_CORNER_VELOCITY="{
	(params.X|default(0)|float, params.Y|default(0)|float)|min}"
	{% else %}
	SET_VELOCITY_LIMIT
	{% endif %}

[gcode_macro m900]
description = Sets pressure advance.
	Usage: M900 [K<advance>] [T<extruder_index>]
gcode = 
	{% set km = printer["gcode_macro _km_globals"] %}
	{% if km.pressure_advance_scale > 0.0 %}
	{% set extruder = "extruder" ~ params.T|replace('0', '')
	if "T" in params else printer.toolhead.extruder %}
	{% if 'K' in params %}
	SET_PRESSURE_ADVANCE EXTRUDER="{extruder}" ADVANCE="{
	params.K|float * km.pressure_advance_scale}"
	{% endif %}
	{% endif %}

[gcode_macro _reset_velocity_limits]
description = Sets maximum accelleration.
	Usage: M204 [S<accel>] [P<accel> T<accel>]
gcode = 
	SET_GCODE_VARIABLE MACRO=m201 VARIABLE=max_accel VALUE="{1.7976931348623157e+308}"

[gcode_macro bed_mesh_calibrate]
rename_existing = _KM_BED_MESH_CALIBRATE_BASE
description = Wraps BED_MESH_CALIBRATE, scaling probe count to specified area.
	Usage: See Klipper documentation.
gcode = 
	BED_MESH_CALIBRATE_FAST{%for k in params%}{' '~k~'="'~params[k]~'"'}{%endfor%}

[gcode_macro g29]
gcode = 
	BED_MESH_CALIBRATE

[idle_timeout]
gcode = 
	_KM_IDLE_TIMEOUT

[respond]

[gcode_macro PRINT_START]
rename_existing = KM_PRINT_START
gcode = 
	
	STATUS_HOMING
	KM_PRINT_START {rawparams}
	STATUS_PRINTING

[board_pins EBB36_G0B1_v1.2]
mcu = ebbcan
aliases = 
aliases_step = 
	EXT_EN=PD2,EXT_STEP=PD0,EXT_DIR=PD1,EXT_UART=PA15
aliases_limitsw = 
	LIMIT_1=PB7,LIMIT_2=PB5,LIMIT_3=PB6
aliases_bltouch = 
	PROBE_1=PB9,PROBE_2=PB8
aliases_fans = 
	FAN0=PA1,FAN1=PA0
aliases_thermistors = 
	TH0=PA3,PT100_CS=PA4,PT100_SCLK=PA5,PT100_MISO=PA6,PT100_MOSI=PA7
aliases_heaters = 
	HE0=PB13
aliases_rgb = 
	RGBLED=PD3
aliases_adxl = 
	ADXL_CS=PB12,ADXL_SCLK=PB10,ADXL_MISO=PB2,ADXL_MOSI=PB11
aliases_i2c = 
	AUX0=PB3,AUX1=PB4

[neopixel sb_leds]
pin = ebbcan:RGBLED
chain_count = 3
color_order = GRB
initial_red = 0.0
initial_green = 0.0
initial_blue = 0.0
initial_white = 1.0

[save_variables]
filename = ~/printer_data/variables.cfg

[mcu CB1]
serial = /tmp/klipper_host_mcu

[mcu]
canbus_uuid = f94e10a9add8

[mcu ebbcan]
canbus_uuid = 57244ec148c0

[printer]
kinematics = corexy
max_velocity = 600
max_accel = 10000
max_accel_to_decel = 5000
max_z_velocity = 5
max_z_accel = 100

[stepper_x]
step_pin = PE2
dir_pin = !PB4
enable_pin = !PC11
microsteps = 16
rotation_distance = 40
endstop_pin = !ebbcan:LIMIT_2
position_endstop = 220
position_min = -4
position_max = 220
homing_speed = 50

[tmc2209 stepper_x]
uart_pin = PC10
diag_pin = PF3
run_current = 1.1

[tmc2209 stepper_y]
uart_pin = PF13
diag_pin = PF4
run_current = 1.1

[tmc2209 stepper_z]
uart_pin = PF9
diag_pin = PF5
run_current = 0.650

[tmc2209 extruder]
uart_pin = ebbcan:EXT_UART
diag_pin = ebbcan:LIMIT_3
run_current = 0.650

[stepper_y]
step_pin = PF12
dir_pin = !PF11
enable_pin = !PB3
microsteps = 16
rotation_distance = 40
endstop_pin = ^PF3
position_endstop = 220
position_min = -4
position_max = 220
homing_speed = 50

[stepper_z]
step_pin = PD7
dir_pin = !PD6
enable_pin = !PF10
microsteps = 16
rotation_distance = 8
endstop_pin = probe:z_virtual_endstop
position_max = 300
position_min = -3

[heater_bed]
heater_pin = PB7
sensor_type = EPCOS 100K B57560G104F
sensor_pin = PA0
min_temp = 0
max_temp = 130
control = pid
pid_kp = 63.528
pid_ki = 0.875
pid_kd = 1153.041

[temperature_sensor raspberry_pi]
sensor_type = temperature_host
min_temp = 10
max_temp = 100

[temperature_sensor mcu_temp]
sensor_type = temperature_mcu
min_temp = 0
max_temp = 100

[controller_fan MCU_Fan]
pin = PE6
heater = extruder
fan_speed = 1

[heater_fan heatbreak_cooling_fan]
pin = ebbcan:FAN0
kick_start_time = 0.25
heater = extruder
heater_temp = 50.0
fan_speed = 1

[fan]
pin = ebbcan:FAN1

[safe_z_home]
home_xy_position = 140, 140
speed = 100
z_hop = 10
z_hop_speed = 20

[extruder]
step_pin = ebbcan:EXT_STEP
dir_pin = ebbcan:EXT_DIR
enable_pin = !ebbcan:EXT_EN
microsteps = 16
rotation_distance = 4.71
full_steps_per_rotation = 200
nozzle_diameter = 0.400
filament_diameter = 1.750
max_extrude_only_distance = 101.0
heater_pin = ebbcan:HE0
sensor_type = ATC Semitec 104NT-4-R025H42G
sensor_pin = ebbcan:TH0
min_temp = 0
max_temp = 300
max_extrude_cross_section = 5
pressure_advance = 0.02
control = pid
pid_kp = 20.603
pid_ki = 0.988
pid_kd = 107.392

[bltouch]
sensor_pin = ebbcan:PROBE_2
control_pin = ebbcan:PROBE_1
x_offset = -40
y_offset = -17
samples = 2
samples_tolerance = 0.015
samples_tolerance_retries = 5
z_offset = 2.849

[bed_mesh]
speed = 100
horizontal_move_z = 5
mesh_min = 10, 27
mesh_max = 173, 200
probe_count = 5, 5
algorithm = bicubic
fade_start = 1
fade_end = 10

[bed_screws]
screw1 = 55,55
screw2 = 200,55
screw3 = 200,205
screw4 = 55,205

[screws_tilt_adjust]
screw1 = 65,55
screw1_name = front left screw
screw2 = 218,55
screw2_name = front right screw
screw3 = 218,215
screw3_name = rear right screw
screw4 = 65,215
screw4_name = rear left screw
horizontal_move_z = 10
speed = 50
screw_thread = CW-M4

[display]
lcd_type = st7920
cs_pin = PB12
sclk_pin = PB13
sid_pin = PB15
encoder_pins = ^PB14, ^PB10
click_pin = ^!PB2

[exclude_object]

[firmware_retraction]
retract_length = 0.4
retract_speed = 20
unretract_extra_length = 0
unretract_speed = 10

[input_shaper]
shaper_type_x = 2hump_ei
shaper_freq_x = 86.2
shaper_type_y = zv
shaper_freq_y = 44.8

[gcode_arcs]
resolution = 1.0

[adxl345]
cs_pin = ebbcan:ADXL_CS
spi_software_sclk_pin = ebbcan:ADXL_SCLK
spi_software_mosi_pin = ebbcan:ADXL_MOSI
spi_software_miso_pin = ebbcan:ADXL_MISO

[resonance_tester]
accel_chip = adxl345
probe_points = 
	120,120,20

[bed_mesh default]
version = 1
points = 
	0.027500, 0.058750, 0.091250, 0.182500
	-0.003750, 0.061250, 0.072500, 0.125000
	0.021250, 0.016250, 0.013750, 0.033750
	-0.023750, -0.018750, -0.036250, -0.037500
x_count = 4
y_count = 4
mesh_x_pps = 2
mesh_y_pps = 2
algo = bicubic
tension = 0.2
min_x = 48.75
max_x = 171.24
min_y = 48.75
max_y = 171.24
=======================
Extruder max_extrude_ratio=2.078758
mcu 'mcu': Starting CAN connect
Created a socket
webhooks client 281473220068064: New connection
webhooks client 281473220068064: Client info {'program': 'Moonraker', 'version': 'v0.8.0-92-g504a3a7'}
Loaded MCU 'mcu' 109 commands (v0.11.0-241-gffb5105b / gcc: (15:8-2019-q3-1+b1) 8.3.1 20190703 (release) [gcc-8-branch revision 273027] binutils: (2.35.2-2+14+b2) 2.35.2)
MCU 'mcu' config: ADC_MAX=4095 BUS_PINS_i2c1_PA9_PA10=PA9,PA10 BUS_PINS_i2c1_PB6_PB7=PB6,PB7 BUS_PINS_i2c1_PB8_PB9=PB8,PB9 BUS_PINS_i2c2_PB10_PB11=PB10,PB11 BUS_PINS_i2c2_PB13_PB14=PB13,PB14 BUS_PINS_i2c3_PB3_PB4=PB3,PB4 BUS_PINS_spi1=PA6,PA7,PA5 BUS_PINS_spi1a=PB4,PB5,PB3 BUS_PINS_spi2=PB14,PB15,PB13 BUS_PINS_spi2a=PC2,PC3,PB10 BUS_PINS_spi3=PB4,PB5,PB3 CANBUS_BRIDGE=1 CLOCK_FREQ=64000000 MCU=stm32g0b1xx PWM_MAX=255 RECEIVE_WINDOW=192 RESERVE_PINS_CAN=PD12,PD13 RESERVE_PINS_USB=PA11,PA12 RESERVE_PINS_crystal=PF0,PF1 STATS_SUMSQ_BASE=256 STEPPER_BOTH_EDGE=1
mcu 'CB1': Starting connect
Loaded MCU 'CB1' 113 commands (v0.11.0-241-gffb5105b / gcc: (Debian 10.2.1-6) 10.2.1 20210110 binutils: (GNU Binutils for Debian) 2.35.2)
MCU 'CB1' config: ADC_MAX=4095 CLOCK_FREQ=50000000 MCU=linux PCA9685_MAX=4096 PWM_MAX=32768 STATS_SUMSQ_BASE=256
mcu 'ebbcan': Starting CAN connect
Created a socket
mcu 'ebbcan': Timeout on connect
Created a socket
mcu 'ebbcan': Wait for identify_response
Traceback (most recent call last):
  File "/home/biqu/klipper/klippy/serialhdl.py", line 68, in _get_identify_data
    params = self.send_with_response(msg, 'identify_response')
  File "/home/biqu/klipper/klippy/serialhdl.py", line 261, in send_with_response
    return src.get_response([cmd], self.default_cmd_queue)
  File "/home/biqu/klipper/klippy/serialhdl.py", line 318, in get_response
    self.serial.raw_send_wait_ack(cmds[-1], minclock, reqclock,
  File "/home/biqu/klipper/klippy/serialhdl.py", line 253, in raw_send_wait_ack
    self._error("Serial connection closed")
  File "/home/biqu/klipper/klippy/serialhdl.py", line 61, in _error
    raise error(self.warn_prefix + (msg % params))
serialhdl.error: mcu 'ebbcan': Serial connection closed
mcu 'ebbcan': Timeout on connect
Created a socket
mcu 'ebbcan': Wait for identify_response
Traceback (most recent call last):
  File "/home/biqu/klipper/klippy/serialhdl.py", line 68, in _get_identify_data
    params = self.send_with_response(msg, 'identify_response')
  File "/home/biqu/klipper/klippy/serialhdl.py", line 261, in send_with_response
    return src.get_response([cmd], self.default_cmd_queue)
  File "/home/biqu/klipper/klippy/serialhdl.py", line 318, in get_response
    self.serial.raw_send_wait_ack(cmds[-1], minclock, reqclock,
  File "/home/biqu/klipper/klippy/serialhdl.py", line 253, in raw_send_wait_ack
    self._error("Serial connection closed")
  File "/home/biqu/klipper/klippy/serialhdl.py", line 61, in _error
    raise error(self.warn_prefix + (msg % params))
serialhdl.error: mcu 'ebbcan': Serial connection closed
mcu 'ebbcan': Timeout on connect
Created a socket
mcu 'ebbcan': Wait for identify_response
Traceback (most recent call last):
  File "/home/biqu/klipper/klippy/serialhdl.py", line 68, in _get_identify_data
    params = self.send_with_response(msg, 'identify_response')
  File "/home/biqu/klipper/klippy/serialhdl.py", line 261, in send_with_response
    return src.get_response([cmd], self.default_cmd_queue)
  File "/home/biqu/klipper/klippy/serialhdl.py", line 318, in get_response
    self.serial.raw_send_wait_ack(cmds[-1], minclock, reqclock,
  File "/home/biqu/klipper/klippy/serialhdl.py", line 253, in raw_send_wait_ack
    self._error("Serial connection closed")
  File "/home/biqu/klipper/klippy/serialhdl.py", line 61, in _error
    raise error(self.warn_prefix + (msg % params))
serialhdl.error: mcu 'ebbcan': Serial connection closed
mcu 'ebbcan': Timeout on connect
Created a socket
mcu 'ebbcan': Wait for identify_response
Traceback (most recent call last):
  File "/home/biqu/klipper/klippy/serialhdl.py", line 68, in _get_identify_data
    params = self.send_with_response(msg, 'identify_response')
  File "/home/biqu/klipper/klippy/serialhdl.py", line 261, in send_with_response
    return src.get_response([cmd], self.default_cmd_queue)
  File "/home/biqu/klipper/klippy/serialhdl.py", line 318, in get_response
    self.serial.raw_send_wait_ack(cmds[-1], minclock, reqclock,
  File "/home/biqu/klipper/klippy/serialhdl.py", line 253, in raw_send_wait_ack
    self._error("Serial connection closed")
  File "/home/biqu/klipper/klippy/serialhdl.py", line 61, in _error
    raise error(self.warn_prefix + (msg % params))
serialhdl.error: mcu 'ebbcan': Serial connection closed
